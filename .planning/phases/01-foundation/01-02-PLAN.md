---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/asset_optimization/portfolio.py
  - src/asset_optimization/quality.py
  - src/asset_optimization/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can load portfolio from CSV with Portfolio.from_csv()"
    - "User can load portfolio from Excel with Portfolio.from_excel()"
    - "User can load portfolio from DataFrame with Portfolio.from_dataframe()"
    - "Invalid data raises ValidationError with structured details"
    - "User can access quality metrics via portfolio.quality property"
    - "User can query assets by ID via portfolio['PIPE-001']"
    - "User can filter assets via portfolio.data property"
  artifacts:
    - path: "src/asset_optimization/portfolio.py"
      provides: "Portfolio class with loading and querying"
      exports: ["Portfolio"]
      min_lines: 150
    - path: "src/asset_optimization/quality.py"
      provides: "QualityMetrics dataclass with rich display"
      exports: ["QualityMetrics"]
      min_lines: 30
  key_links:
    - from: "src/asset_optimization/portfolio.py"
      to: "src/asset_optimization/schema.py"
      via: "import portfolio_schema"
      pattern: "from .schema import portfolio_schema"
    - from: "src/asset_optimization/portfolio.py"
      to: "src/asset_optimization/quality.py"
      via: "import QualityMetrics"
      pattern: "from .quality import QualityMetrics"
    - from: "src/asset_optimization/portfolio.py"
      to: "src/asset_optimization/exceptions.py"
      via: "import ValidationError"
      pattern: "from .exceptions import"
---

<objective>
Implement Portfolio class with CSV/Excel loading, validation, quality metrics, and query capabilities.

Purpose: Deliver the core user-facing API for loading and working with asset portfolios. This is the primary interface users will interact with.

Output: Fully functional Portfolio class that loads, validates, and exposes asset data with quality metrics.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QualityMetrics dataclass</name>
  <files>
    src/asset_optimization/quality.py
  </files>
  <action>
Create `src/asset_optimization/quality.py` with:

1. `QualityMetrics` dataclass with:
   - `completeness: pd.Series` — percentage of non-null values per column (0.0-1.0)
   - `missing_counts: pd.Series` — count of missing values per column
   - `total_rows: int` — total number of assets

2. `__repr__` method:
   - Format as table showing columns with completeness % and missing count
   - Terminal-friendly (no HTML)

3. `_repr_html_` method:
   - Rich HTML display for Jupyter notebooks
   - Use pandas DataFrame's _repr_html_() for the summary table

Use the pattern from RESEARCH.md "Pattern 5: Quality Metrics as Property".
  </action>
  <verify>
Run: `python -c "from asset_optimization.quality import QualityMetrics; import pandas as pd; qm = QualityMetrics(pd.Series({'a': 0.9}), pd.Series({'a': 1}), 10); print(repr(qm))"`
Expected: Prints formatted quality metrics table.
  </verify>
  <done>QualityMetrics dataclass exists with rich display for REPL and notebooks.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Portfolio class</name>
  <files>
    src/asset_optimization/portfolio.py
    src/asset_optimization/__init__.py
  </files>
  <action>
Create `src/asset_optimization/portfolio.py` with Portfolio class:

**Factory Methods (class methods):**

1. `from_csv(cls, path, **kwargs) -> Portfolio`:
   - Load CSV with explicit dtypes (from RESEARCH.md "Pattern 2"):
     - asset_id: str, asset_type: str, material: str
     - diameter_mm: 'Int64', length_m: float, condition_score: float
   - parse_dates=['install_date']
   - Pass **kwargs to pd.read_csv for flexibility
   - Call _load_data() to validate and store

2. `from_excel(cls, path, **kwargs) -> Portfolio`:
   - Same dtypes as CSV
   - Use engine='openpyxl'
   - Pass **kwargs to pd.read_excel
   - Call _load_data() to validate and store

3. `from_dataframe(cls, df: pd.DataFrame) -> Portfolio`:
   - Accept already-loaded DataFrame
   - Call _load_data() to validate and store

**Internal Methods:**

4. `_load_data(self, df: pd.DataFrame)`:
   - Validate using portfolio_schema from schema.py
   - Wrap Pandera SchemaError in ValidationError with structured details
   - Store validated DataFrame in self._data
   - Compute and store QualityMetrics in self._quality
   - Compute and store self._n_assets = len(df)

5. `_compute_quality(self, df) -> QualityMetrics`:
   - completeness = df.notna().mean()
   - missing_counts = df.isna().sum()
   - Return QualityMetrics instance

**Properties:**

6. `data` property → pd.DataFrame:
   - Returns self._data for filtering operations
   - User can do: `portfolio.data[portfolio.data['asset_type'] == 'pipe']`

7. `quality` property → QualityMetrics:
   - Returns self._quality
   - Raises AttributeError if no data loaded

8. `asset_types` property → list[str]:
   - Returns unique asset types: `self._data['asset_type'].unique().tolist()`

9. `mean_age` property → float:
   - Calculate mean age in years from install_date to today
   - Use: `(pd.Timestamp.now() - self._data['install_date']).dt.days / 365.25`

10. `age_distribution` property → pd.Series:
    - Returns Series of ages in years for all assets

11. `oldest` property → pd.Series:
    - Returns the row with the oldest install_date

12. `newest` property → pd.Series:
    - Returns the row with the newest install_date

**Dunder Methods:**

13. `__len__(self) -> int`:
    - Returns self._n_assets

14. `__getitem__(self, asset_id: str) -> pd.Series`:
    - Dict-like access: `portfolio['PIPE-001']`
    - Returns the row as Series
    - Raises KeyError if asset_id not found

15. `__repr__(self) -> str`:
    - Informative repr (from CONTEXT.md):
    - Format: `Portfolio(n_assets=1000, types=['pipe', 'valve'], date_range='2010-2020')`
    - If no data: `Portfolio(empty)`

**Update __init__.py:**
- Import Portfolio from portfolio.py
- Add to __all__ list
  </action>
  <verify>
Run:
```
python -c "
from asset_optimization import Portfolio
import pandas as pd

# Create test data
df = pd.DataFrame({
    'asset_id': ['PIPE-001', 'PIPE-002'],
    'install_date': pd.to_datetime(['2015-01-01', '2020-06-15']),
    'asset_type': ['pipe', 'pipe'],
    'material': ['PVC', 'Cast Iron'],
})

p = Portfolio.from_dataframe(df)
print(f'len: {len(p)}')
print(f'types: {p.asset_types}')
print(f'quality: {p.quality}')
print(f'repr: {repr(p)}')
print(f'item: {p[\"PIPE-001\"][\"material\"]}')
"
```
Expected: All operations succeed, showing 2 assets, types=['pipe'], quality metrics, informative repr, and 'PVC' for material.
  </verify>
  <done>Portfolio class loads CSV/Excel/DataFrame, validates, and provides quality metrics and query access.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `Portfolio.from_csv()` loads valid CSV files
2. `Portfolio.from_excel()` loads valid Excel files
3. `Portfolio.from_dataframe()` loads valid DataFrames
4. Invalid data (missing required fields, future dates, duplicate IDs) raises ValidationError
5. `portfolio.quality` returns QualityMetrics with completeness and missing_counts
6. `portfolio.data` returns DataFrame for filtering
7. `portfolio['PIPE-001']` returns asset row
8. `len(portfolio)` returns asset count
9. `repr(portfolio)` shows informative summary
</verification>

<success_criteria>
- Portfolio loads from CSV, Excel, and DataFrame
- Validation rejects invalid data with structured error messages
- Quality metrics computed and accessible
- Dict-like access works for asset lookup
- All properties (asset_types, mean_age, age_distribution, oldest, newest) work
- repr is informative in REPL
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
