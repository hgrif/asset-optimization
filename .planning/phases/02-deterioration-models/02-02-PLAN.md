---
phase: 02-deterioration-models
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/asset_optimization/models/weibull.py
  - src/asset_optimization/models/__init__.py
  - src/asset_optimization/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can create WeibullModel with parameters per asset type"
    - "WeibullModel.transform() adds failure_rate and failure_probability columns"
    - "Model rejects asset types not in parameters dict (fail fast)"
    - "Invalid Weibull parameters (<=0) rejected at initialization"
    - "transform() returns a copy, does not modify input DataFrame"
  artifacts:
    - path: "src/asset_optimization/models/weibull.py"
      provides: "Weibull 2-parameter deterioration model"
      contains: "class WeibullModel(DeteriorationModel)"
      min_lines: 100
    - path: "src/asset_optimization/models/__init__.py"
      provides: "Module exports including WeibullModel"
      exports: ["DeteriorationModel", "WeibullModel"]
  key_links:
    - from: "src/asset_optimization/models/weibull.py"
      to: "scipy.stats.weibull_min"
      via: "import for CDF calculation"
      pattern: "from scipy.stats import weibull_min"
    - from: "src/asset_optimization/models/weibull.py"
      to: "src/asset_optimization/models/base.py"
      via: "inheritance"
      pattern: "class WeibullModel\\(DeteriorationModel\\)"
    - from: "src/asset_optimization/__init__.py"
      to: "src/asset_optimization/models"
      via: "re-export WeibullModel"
      pattern: "from .models import WeibullModel"
---

<objective>
Implement the Weibull 2-parameter deterioration model with vectorized operations.

Purpose: Enable calculation of failure rates for entire portfolios using industry-standard Weibull distribution, configurable per asset type (DTRN-01, DTRN-02, DTRN-03).

Output: WeibullModel class with transform() that adds failure_rate and failure_probability columns to portfolio DataFrames.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-deterioration-models/02-RESEARCH.md
@.planning/phases/02-deterioration-models/02-01-SUMMARY.md

# Dependencies from Plan 01
@src/asset_optimization/models/base.py
@src/asset_optimization/models/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WeibullModel class</name>
  <files>src/asset_optimization/models/weibull.py</files>
  <action>
Create the Weibull model implementation following the research patterns.

**Create `src/asset_optimization/models/weibull.py`:**

Key implementation details from RESEARCH.md:
- Use direct formula for hazard rate: h(t) = (k/λ) * (t/λ)^(k-1) (3-5x faster than scipy)
- Use scipy.stats.weibull_min.cdf() for failure probability
- Vectorize per asset type using groupby
- Return copy of DataFrame (immutable pattern)
- Validate parameters in __init__ (fail fast)
- Handle age=0 case by defining h(0) = 0

```python
"""Weibull 2-parameter deterioration model."""

import numpy as np
import pandas as pd
from scipy.stats import weibull_min

from .base import DeteriorationModel


class WeibullModel(DeteriorationModel):
    """Weibull 2-parameter deterioration model.

    Calculates failure rates using the Weibull distribution, which models
    increasing failure rates over time (typical for aging infrastructure).

    Parameters
    ----------
    params : dict[str, tuple[float, float]]
        Maps asset type to (shape, scale) parameters.
        - shape (k): Controls failure rate behavior
          - k < 1: Decreasing failure rate (infant mortality)
          - k = 1: Constant failure rate (exponential)
          - k > 1: Increasing failure rate (wear-out, typical for pipes)
        - scale (λ): Characteristic life in years
        Example: {'PVC': (2.5, 50), 'Cast Iron': (3.0, 40)}
    type_column : str, default='material'
        Column name identifying asset type for parameter lookup.
    age_column : str, default='age'
        Column name with asset ages in years.

    Attributes
    ----------
    params : dict
        Weibull parameters per asset type.
    type_column : str
        Column name for asset type.
    age_column : str
        Column name for age.

    Examples
    --------
    >>> params = {'PVC': (2.5, 50), 'Cast Iron': (3.0, 40)}
    >>> model = WeibullModel(params)
    >>> enriched = model.transform(portfolio.data)
    >>> enriched[['asset_id', 'age', 'failure_rate', 'failure_probability']]

    Notes
    -----
    The Weibull distribution is widely used in water infrastructure:
    - Typical shape values: 2-4 (increasing failure rate)
    - Typical scale values: 30-80 years (characteristic life)

    References
    ----------
    Weibull, W. (1951). A statistical distribution function of wide applicability.
    Journal of Applied Mechanics, 18(3), 293-297.
    """

    def __init__(
        self,
        params: dict[str, tuple[float, float]],
        type_column: str = 'material',
        age_column: str = 'age',
    ):
        """Initialize WeibullModel with parameters per asset type.

        Parameters
        ----------
        params : dict[str, tuple[float, float]]
            Maps asset type to (shape, scale) tuple.
        type_column : str, default='material'
            Column name identifying asset type.
        age_column : str, default='age'
            Column name with asset ages.

        Raises
        ------
        ValueError
            If params is empty or contains invalid values (shape/scale <= 0).
        """
        self.params = params
        self.type_column = type_column
        self.age_column = age_column
        self._validate_params()

    def _validate_params(self) -> None:
        """Validate Weibull parameters at initialization.

        Raises
        ------
        ValueError
            If params dict is empty or contains invalid values.
        """
        if not self.params:
            raise ValueError("params dict cannot be empty")

        for asset_type, param_tuple in self.params.items():
            if not isinstance(param_tuple, tuple) or len(param_tuple) != 2:
                raise ValueError(
                    f"Parameters for '{asset_type}' must be (shape, scale) tuple, "
                    f"got {param_tuple}"
                )

            shape, scale = param_tuple
            if shape <= 0:
                raise ValueError(
                    f"Shape parameter must be > 0 for '{asset_type}', got {shape}"
                )
            if scale <= 0:
                raise ValueError(
                    f"Scale parameter must be > 0 for '{asset_type}', got {scale}"
                )

    def _validate_dataframe(self, df: pd.DataFrame) -> None:
        """Validate DataFrame has required columns and types.

        Parameters
        ----------
        df : pd.DataFrame
            DataFrame to validate.

        Raises
        ------
        ValueError
            If required columns missing or asset types not in params.
        TypeError
            If age column is not numeric.
        """
        # Check required columns exist
        required = [self.age_column, self.type_column]
        missing = [col for col in required if col not in df.columns]
        if missing:
            raise ValueError(
                f"Required columns missing: {missing}. "
                f"Available columns: {df.columns.tolist()}"
            )

        # Check age column is numeric
        if not pd.api.types.is_numeric_dtype(df[self.age_column]):
            raise TypeError(
                f"Age column '{self.age_column}' must be numeric, "
                f"got {df[self.age_column].dtype}"
            )

        # Check all asset types have parameters
        df_types = set(df[self.type_column].unique())
        param_types = set(self.params.keys())
        missing_types = df_types - param_types
        if missing_types:
            raise ValueError(
                f"Asset types in data missing from params: {missing_types}. "
                f"Provide Weibull parameters for all asset types or filter data."
            )

    def failure_rate(
        self,
        age: np.ndarray,
        shape: float | None = None,
        scale: float | None = None,
    ) -> np.ndarray:
        """Calculate Weibull failure rate (hazard function).

        h(t) = (k/λ) * (t/λ)^(k-1)
        where k=shape, λ=scale

        Parameters
        ----------
        age : np.ndarray
            Asset ages in years.
        shape : float, optional
            Weibull shape parameter (k). Required if not using transform().
        scale : float, optional
            Weibull scale parameter (λ). Required if not using transform().

        Returns
        -------
        rates : np.ndarray
            Failure rates (instantaneous hazard).

        Raises
        ------
        ValueError
            If shape or scale not provided.

        Notes
        -----
        Uses direct formula (3-5x faster than scipy pdf/sf approach).
        Defines h(0) = 0 for numerical stability.
        """
        if shape is None or scale is None:
            raise ValueError("shape and scale parameters required for failure_rate()")

        # Direct formula is faster than scipy.stats approach
        # Handle age=0 case: define h(0) = 0 for stability
        with np.errstate(divide='ignore', invalid='ignore'):
            rates = (shape / scale) * np.power(age / scale, shape - 1)
            rates = np.where(age == 0, 0.0, rates)

        return rates

    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        """Add failure_rate and failure_probability columns to DataFrame.

        Parameters
        ----------
        df : pd.DataFrame
            Portfolio DataFrame with age and type columns.

        Returns
        -------
        enriched : pd.DataFrame
            Copy of input with two new columns:
            - failure_rate: instantaneous hazard h(t)
            - failure_probability: cumulative probability F(t) = CDF

        Raises
        ------
        ValueError
            If required columns missing or asset types not in params.
        TypeError
            If age column is not numeric.

        Examples
        --------
        >>> params = {'PVC': (2.5, 50)}
        >>> model = WeibullModel(params)
        >>> df = pd.DataFrame({'material': ['PVC'], 'age': [10]})
        >>> result = model.transform(df)
        >>> result['failure_probability'].iloc[0]
        0.0055...
        """
        # Validate input
        self._validate_dataframe(df)

        # Create copy for immutability (aligns with pandas CoW pattern)
        result = df.copy(deep=True)

        # Initialize output columns
        result['failure_rate'] = np.nan
        result['failure_probability'] = np.nan

        # Calculate per asset type (vectorized within each group)
        for asset_type, group_df in df.groupby(self.type_column):
            shape, scale = self.params[asset_type]
            ages = group_df[self.age_column].values

            # Vectorized failure rate calculation
            rates = self.failure_rate(ages, shape=shape, scale=scale)

            # Vectorized failure probability (CDF)
            probs = weibull_min.cdf(ages, c=shape, scale=scale)

            # Assign to result DataFrame
            result.loc[group_df.index, 'failure_rate'] = rates
            result.loc[group_df.index, 'failure_probability'] = probs

        return result

    def __repr__(self) -> str:
        """Return informative string representation."""
        types = list(self.params.keys())
        return (
            f"WeibullModel(types={types}, "
            f"type_column='{self.type_column}', "
            f"age_column='{self.age_column}')"
        )
```
  </action>
  <verify>
uv run python -c "
from asset_optimization.models.weibull import WeibullModel
import pandas as pd
import numpy as np

# Test instantiation
params = {'PVC': (2.5, 50), 'Cast Iron': (3.0, 40)}
model = WeibullModel(params)
print(f'Created: {model}')

# Test transform
df = pd.DataFrame({
    'asset_id': ['P1', 'P2', 'P3'],
    'material': ['PVC', 'PVC', 'Cast Iron'],
    'age': [10, 20, 30],
})
result = model.transform(df)
print(f'Columns: {result.columns.tolist()}')
print(f'Has failure_rate: {\"failure_rate\" in result.columns}')
print(f'Has failure_probability: {\"failure_probability\" in result.columns}')

# Test immutability
print(f'Original unchanged: {\"failure_rate\" not in df.columns}')
"
  </verify>
  <done>WeibullModel instantiates with params, transform() adds failure_rate and failure_probability columns</done>
</task>

<task type="auto">
  <name>Task 2: Export WeibullModel from package</name>
  <files>src/asset_optimization/models/__init__.py, src/asset_optimization/__init__.py</files>
  <action>
Update the module exports to include WeibullModel.

**Update `src/asset_optimization/models/__init__.py`:**

```python
"""Deterioration models for asset failure rate calculations."""

from .base import DeteriorationModel
from .weibull import WeibullModel

__all__ = ["DeteriorationModel", "WeibullModel"]
```

**Update `src/asset_optimization/__init__.py`:**

Add WeibullModel to the top-level exports so users can do:
`from asset_optimization import WeibullModel`

```python
"""Asset portfolio optimization for infrastructure management."""

__version__ = "0.1.0"

from .portfolio import Portfolio
from .exceptions import (
    ValidationError,
    MissingFieldError,
    DataQualityError,
)
from .models import WeibullModel

__all__ = [
    "__version__",
    "Portfolio",
    "ValidationError",
    "MissingFieldError",
    "DataQualityError",
    "WeibullModel",
]
```
  </action>
  <verify>
uv run python -c "
# Test import from models subpackage
from asset_optimization.models import DeteriorationModel, WeibullModel
print('Import from models: OK')

# Test import from top-level
from asset_optimization import WeibullModel
print('Import from top-level: OK')

# Check it's a DeteriorationModel subclass
print(f'Is DeteriorationModel subclass: {issubclass(WeibullModel, DeteriorationModel)}')
"
  </verify>
  <done>WeibullModel importable from both asset_optimization and asset_optimization.models</done>
</task>

</tasks>

<verification>
Run comprehensive checks:
```bash
# 1. WeibullModel works end-to-end
uv run python -c "
from asset_optimization import Portfolio, WeibullModel
import pandas as pd

# Create sample portfolio data with age column
df = pd.DataFrame({
    'asset_id': [f'PIPE-{i:03d}' for i in range(100)],
    'install_date': pd.date_range('2010-01-01', periods=100, freq='M'),
    'asset_type': ['pipe'] * 100,
    'material': ['PVC'] * 50 + ['Cast Iron'] * 50,
    'age': list(range(1, 51)) * 2,  # Ages 1-50 for each material
})

# Create Weibull model
params = {'PVC': (2.5, 50), 'Cast Iron': (3.0, 40)}
model = WeibullModel(params)

# Transform
result = model.transform(df)
print(f'Rows: {len(result)}')
print(f'Columns: {result.columns.tolist()}')
print(f'Failure rate range: {result[\"failure_rate\"].min():.4f} - {result[\"failure_rate\"].max():.4f}')
print(f'Failure probability range: {result[\"failure_probability\"].min():.4f} - {result[\"failure_probability\"].max():.4f}')
"

# 2. Error cases work
uv run python -c "
from asset_optimization import WeibullModel
import pandas as pd

# Test empty params
try:
    WeibullModel({})
except ValueError as e:
    print(f'Empty params rejected: {e}')

# Test invalid shape
try:
    WeibullModel({'PVC': (-1, 50)})
except ValueError as e:
    print(f'Negative shape rejected: {e}')

# Test missing asset type
try:
    model = WeibullModel({'PVC': (2.5, 50)})
    df = pd.DataFrame({'material': ['HDPE'], 'age': [10]})
    model.transform(df)
except ValueError as e:
    print(f'Missing type rejected: {e}')
"

# 3. Existing tests still pass
uv run pytest tests/ -v --tb=short
```
</verification>

<success_criteria>
1. WeibullModel instantiates with valid params dict
2. Invalid params (empty, negative shape/scale) rejected at __init__
3. transform() adds failure_rate and failure_probability columns
4. transform() returns a copy (original DataFrame unchanged)
5. Missing asset type in params raises ValueError
6. Missing required columns raise ValueError
7. Non-numeric age column raises TypeError
8. WeibullModel importable from top-level package
9. All existing Phase 1 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterioration-models/02-02-SUMMARY.md`
</output>
