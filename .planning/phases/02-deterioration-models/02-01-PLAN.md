---
phase: 02-deterioration-models
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/models/__init__.py
  - src/asset_optimization/models/base.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "DeteriorationModel abstract base class exists with required abstract methods"
    - "Attempting to instantiate DeteriorationModel raises TypeError"
    - "scipy>=1.10.0 is listed as a project dependency"
  artifacts:
    - path: "src/asset_optimization/models/__init__.py"
      provides: "Module exports for deterioration models"
      exports: ["DeteriorationModel"]
    - path: "src/asset_optimization/models/base.py"
      provides: "Abstract base class for deterioration models"
      contains: "class DeteriorationModel(ABC)"
  key_links:
    - from: "src/asset_optimization/models/__init__.py"
      to: "src/asset_optimization/models/base.py"
      via: "import and re-export"
      pattern: "from .base import DeteriorationModel"
---

<objective>
Create the abstract base class for pluggable deterioration models and add scipy dependency.

Purpose: Establish the interface contract that all deterioration models must implement, enabling users to swap Weibull for custom models via pluggable architecture (DTRN-04).

Output: DeteriorationModel ABC with failure_rate() and transform() abstract methods, scipy dependency added.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-deterioration-models/02-RESEARCH.md

# Existing code structure
@src/asset_optimization/__init__.py
@src/asset_optimization/portfolio.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scipy dependency to pyproject.toml</name>
  <files>pyproject.toml</files>
  <action>
Add scipy>=1.10.0 to the dependencies list in pyproject.toml.

The dependencies section should become:
```toml
dependencies = [
    "pandas>=2.0.0",
    "openpyxl>=3.1.0",
    "pandera>=0.18.0",
    "scipy>=1.10.0",
]
```

After modifying pyproject.toml, run `uv pip install -e .` to install scipy in the virtual environment.

Verify scipy is importable: `uv run python -c "import scipy; print(scipy.__version__)"`
  </action>
  <verify>uv run python -c "import scipy; print(scipy.__version__)" prints version >= 1.10.0</verify>
  <done>scipy>=1.10.0 listed in pyproject.toml and importable in virtual environment</done>
</task>

<task type="auto">
  <name>Task 2: Create DeteriorationModel abstract base class</name>
  <files>src/asset_optimization/models/__init__.py, src/asset_optimization/models/base.py</files>
  <action>
Create the models subpackage with abstract base class.

**Create `src/asset_optimization/models/` directory**

**Create `src/asset_optimization/models/base.py`:**

```python
"""Abstract base class for deterioration models."""

from abc import ABC, abstractmethod
import numpy as np
import pandas as pd


class DeteriorationModel(ABC):
    """Abstract base for deterioration models.

    All deterioration models must implement:
    - failure_rate(): Calculate instantaneous hazard function
    - transform(): Add failure metrics to portfolio DataFrame

    Models accept full portfolio DataFrames and operate vectorized per asset type.
    The transform() method returns a copy with new columns added (immutable pattern).

    Subclasses should:
    1. Accept parameters at __init__
    2. Validate parameters in __init__ (fail fast)
    3. Implement vectorized calculations for performance

    Examples
    --------
    >>> class CustomModel(DeteriorationModel):
    ...     def __init__(self, params):
    ...         self.params = params
    ...
    ...     def failure_rate(self, age, **kwargs):
    ...         return np.zeros_like(age)  # Custom calculation
    ...
    ...     def transform(self, df):
    ...         result = df.copy()
    ...         result['failure_rate'] = self.failure_rate(df['age'].values)
    ...         result['failure_probability'] = 0.0  # Custom calculation
    ...         return result
    """

    @abstractmethod
    def failure_rate(self, age: np.ndarray, **kwargs) -> np.ndarray:
        """Calculate failure rate (hazard function) at given ages.

        Parameters
        ----------
        age : np.ndarray
            Asset ages in years (vectorized input).
        **kwargs : dict
            Model-specific parameters (e.g., shape, scale for Weibull).

        Returns
        -------
        rates : np.ndarray
            Failure rates (instantaneous hazard function values).
            Same shape as input age array.

        Notes
        -----
        Hazard function h(t) represents instantaneous failure rate.
        For Weibull: h(t) = (k/λ) * (t/λ)^(k-1)
        """
        pass

    @abstractmethod
    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        """Add failure rate and probability columns to portfolio DataFrame.

        Parameters
        ----------
        df : pd.DataFrame
            Portfolio DataFrame with at minimum an age column and
            a type column for parameter lookup.

        Returns
        -------
        enriched : pd.DataFrame
            Copy of input with two new columns added:
            - failure_rate: instantaneous hazard h(t)
            - failure_probability: cumulative probability F(t)

        Raises
        ------
        ValueError
            If required columns missing or asset types not in parameters.
        TypeError
            If age column is not numeric.

        Notes
        -----
        This method MUST return a copy of the input DataFrame.
        The original DataFrame must not be modified (immutable pattern).
        This aligns with pandas copy-on-write behavior in pandas 2.0+.
        """
        pass
```

**Create `src/asset_optimization/models/__init__.py`:**

```python
"""Deterioration models for asset failure rate calculations."""

from .base import DeteriorationModel

__all__ = ["DeteriorationModel"]
```

Verify the ABC works:
1. Import should succeed: `from asset_optimization.models import DeteriorationModel`
2. Instantiation should fail with TypeError: `DeteriorationModel()`
  </action>
  <verify>
uv run python -c "
from asset_optimization.models import DeteriorationModel
print('Import successful')
try:
    DeteriorationModel()
    print('ERROR: Should have raised TypeError')
except TypeError as e:
    print(f'TypeError raised as expected: {e}')
"
  </verify>
  <done>DeteriorationModel ABC importable, cannot be instantiated directly</done>
</task>

</tasks>

<verification>
Run all checks:
```bash
# 1. scipy installed
uv run python -c "import scipy; print(f'scipy version: {scipy.__version__}')"

# 2. ABC importable and not instantiable
uv run python -c "
from asset_optimization.models import DeteriorationModel
from abc import ABC
print(f'Is ABC subclass: {issubclass(DeteriorationModel, ABC)}')
print(f'Has failure_rate: {hasattr(DeteriorationModel, \"failure_rate\")}')
print(f'Has transform: {hasattr(DeteriorationModel, \"transform\")}')
print(f'failure_rate is abstract: {getattr(DeteriorationModel.failure_rate, \"__isabstractmethod__\", False)}')
print(f'transform is abstract: {getattr(DeteriorationModel.transform, \"__isabstractmethod__\", False)}')
"

# 3. Existing tests still pass
uv run pytest tests/ -v --tb=short
```
</verification>

<success_criteria>
1. scipy>=1.10.0 is in pyproject.toml dependencies
2. scipy is importable in virtual environment
3. DeteriorationModel is importable from asset_optimization.models
4. DeteriorationModel is an ABC subclass
5. failure_rate and transform are abstract methods
6. Attempting to instantiate DeteriorationModel raises TypeError
7. All existing Phase 1 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterioration-models/02-01-SUMMARY.md`
</output>
