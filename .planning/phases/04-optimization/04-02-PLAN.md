---
phase: 04-optimization
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/asset_optimization/optimization/optimizer.py
  - src/asset_optimization/optimization/__init__.py
  - src/asset_optimization/__init__.py
autonomous: true

must_haves:
  truths:
    - "Optimizer accepts strategy parameter in constructor"
    - "fit() returns self with result_ attribute"
    - "Greedy strategy selects interventions within budget"
    - "MILP strategy raises NotImplementedError"
    - "Unknown strategy raises ValueError"
  artifacts:
    - path: "src/asset_optimization/optimization/optimizer.py"
      provides: "Optimizer class with fit() method and greedy algorithm"
      exports: ["Optimizer"]
      min_lines: 150
    - path: "src/asset_optimization/optimization/__init__.py"
      provides: "Package exports"
      contains: "from .optimizer import Optimizer"
  key_links:
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "WeibullModel.params"
      via: "model.params access for risk_after calculation"
      pattern: "model\\.params"
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "scipy.stats.weibull_min.cdf"
      via: "risk_after calculation"
      pattern: "weibull_min\\.cdf"
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "OptimizationResult"
      via: "self.result_ assignment"
      pattern: "OptimizationResult"
---

<objective>
Implement Optimizer class with scikit-learn-style fit() API and two-stage greedy algorithm.

Purpose: Core optimization logic -- budget-constrained intervention selection using risk-to-cost ratio prioritization.
Output: optimizer.py with Optimizer class, package exports via __init__.py
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-optimization/04-CONTEXT.md
@.planning/phases/04-optimization/04-RESEARCH.md

# Dependencies from previous plan
@.planning/phases/04-optimization/04-01-SUMMARY.md

# Pattern references
@src/asset_optimization/simulation/interventions.py
@src/asset_optimization/models/weibull.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Optimizer class with fit() and greedy algorithm</name>
  <files>src/asset_optimization/optimization/optimizer.py</files>
  <action>
Create optimizer.py with Optimizer class following scikit-learn conventions:

**Constructor (no validation):**
```python
def __init__(self, strategy: str = 'greedy', min_risk_threshold: float = 0.0):
    self.strategy = strategy
    self.min_risk_threshold = min_risk_threshold
```

**fit() method:**
```python
def fit(self, portfolio, model, budget: float, exclusions: list[str] | None = None) -> 'Optimizer':
    """Select interventions within budget.

    Parameters
    ----------
    portfolio : Portfolio
        Asset portfolio with data DataFrame.
    model : WeibullModel
        Fitted deterioration model (used for risk_after calculation).
    budget : float
        Annual budget (strict upper bound, never exceeded).
    exclusions : list[str], optional
        Asset IDs to skip entirely.

    Returns
    -------
    self
        Fitted optimizer. Access results via result_ attribute.
    """
```

Validation in fit():
- Check strategy is 'greedy' or 'milp'
- Raise ValueError for unknown strategy
- Raise NotImplementedError for 'milp'
- Validate budget >= 0
- Validate portfolio.data has 'failure_probability' column

**Two-stage greedy algorithm (_fit_greedy):**

Stage 1 - Best intervention per asset:
1. Get portfolio.data with failure_probability (from model.transform())
2. Ensure 'age' column exists (compute from install_date if needed)
3. Apply exclusion filter first (skip excluded asset_ids)
4. For each asset, compute risk_after for each intervention (Replace, Repair, Inspect)
   - Use weibull_min.cdf(new_age, c=shape, scale=scale) with model.params
5. Compute cost_effectiveness = (risk_before - risk_after) / cost for non-DoNothing
6. Pick intervention with highest cost_effectiveness per asset
7. Note: Inspect has cost_effectiveness=0 (no risk reduction in v1), will only be selected as budget fallback

Stage 2 - Rank and fill budget:
1. Filter: remove assets below min_risk_threshold
2. Filter: remove assets where best intervention is DoNothing (shouldn't happen, but safety)
3. Compute risk_to_cost_ratio = risk_before / cost
4. Sort: risk_to_cost_ratio DESC, then install_date ASC (oldest first tie-breaker)
5. Greedy fill: iterate, add if cost <= remaining_budget
6. Track selections with rank (1-indexed)

**Build result:**
- selections DataFrame: asset_id, intervention_type, cost, risk_score (=risk_before), rank
- budget_summary DataFrame: budget, spent, remaining, utilization_pct
- Return OptimizationResult(selections, budget_summary, strategy='greedy')

Store as self.result_ (trailing underscore = learned attribute per scikit-learn).
Add result property that raises AttributeError if not fitted.

**Imports needed:**
- pandas, numpy
- scipy.stats.weibull_min
- from .result import OptimizationResult
- from ..simulation import DO_NOTHING, INSPECT, REPAIR, REPLACE
- from ..exceptions import OptimizationError

**Edge cases to handle:**
- Empty portfolio: return empty selections, 0% utilization
- Zero budget: return empty selections
- All assets below threshold: return empty selections
- Budget can't fit any intervention: return empty selections
  </action>
  <verify>
python -c "
from asset_optimization import Portfolio, WeibullModel
from asset_optimization.optimization import Optimizer
import pandas as pd

# Create test portfolio
df = pd.DataFrame({
    'asset_id': ['A1', 'A2', 'A3'],
    'material': ['PVC', 'PVC', 'PVC'],
    'install_date': pd.to_datetime(['2000-01-01', '1990-01-01', '2010-01-01']),
    'condition': [3, 2, 4],
    'diameter_mm': [100, 100, 100],
    'length_m': [100, 100, 100],
    'location': ['Zone1', 'Zone1', 'Zone1']
})
portfolio = Portfolio(df)

# Add age column
portfolio.data['age'] = (pd.Timestamp.now() - portfolio.data['install_date']).dt.days / 365.25

# Create model and enrich
model = WeibullModel({'PVC': (2.5, 50.0)})
portfolio._data = model.transform(portfolio.data)

# Run optimization
opt = Optimizer(strategy='greedy', min_risk_threshold=0.0)
opt.fit(portfolio, model, budget=60000.0)
print(f'Selected: {len(opt.result.selections)} assets')
print(f'Spent: \${opt.result.total_spent:,.0f}')
print(f'Utilization: {opt.result.utilization_pct:.1f}%')
"
  </verify>
  <done>
Optimizer.fit() completes successfully, selects interventions within budget, result_ contains OptimizationResult with populated DataFrames
  </done>
</task>

<task type="auto">
  <name>Task 2: Export Optimizer from package and top-level</name>
  <files>
    src/asset_optimization/optimization/__init__.py
    src/asset_optimization/__init__.py
  </files>
  <action>
Update optimization/__init__.py:
```python
"""Optimization module for budget-constrained intervention selection."""

from .optimizer import Optimizer
from .result import OptimizationResult

__all__ = ['Optimizer', 'OptimizationResult']
```

Update main __init__.py to include optimization exports:
- Add: `from .optimization import Optimizer, OptimizationResult`
- Add to __all__: 'Optimizer', 'OptimizationResult'
- Also add OptimizationError to top-level exports if not already there

Verify import chain works: `from asset_optimization import Optimizer, OptimizationResult`
  </action>
  <verify>
python -c "from asset_optimization import Optimizer, OptimizationResult; print('Optimizer:', Optimizer); print('OptimizationResult:', OptimizationResult)"
  </verify>
  <done>
Optimizer and OptimizationResult importable from top-level asset_optimization package
  </done>
</task>

</tasks>

<verification>
1. `python -c "from asset_optimization import Optimizer"` succeeds
2. Greedy optimization runs: see Task 1 verify script
3. MILP raises NotImplementedError: `python -c "from asset_optimization import Optimizer; Optimizer('milp').fit(None, None, 1000)"`
4. Unknown strategy raises ValueError: `python -c "from asset_optimization import Optimizer; Optimizer('unknown').fit(None, None, 1000)"`
5. All existing tests pass: `pytest tests/ -q`
</verification>

<success_criteria>
- Optimizer class exists with strategy parameter and min_risk_threshold
- fit() accepts portfolio, model, budget, exclusions and returns self
- Greedy algorithm correctly implements two-stage selection
- Budget constraint strictly enforced (never exceeded)
- result property returns OptimizationResult or raises if not fitted
- MILP strategy raises NotImplementedError with clear message
- Package exports work at optimization and top level
</success_criteria>

<output>
After completion, create `.planning/phases/04-optimization/04-02-SUMMARY.md`
</output>
