---
phase: 04-optimization
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - tests/test_optimization.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Tests verify budget constraint is never exceeded"
    - "Tests verify greedy selects highest risk-to-cost ratio first"
    - "Tests verify MILP raises NotImplementedError"
    - "Tests verify exclusion list works correctly"
    - "Tests verify min_risk_threshold filters assets"
  artifacts:
    - path: "tests/test_optimization.py"
      provides: "Comprehensive test suite for optimization module"
      min_lines: 150
  key_links:
    - from: "tests/test_optimization.py"
      to: "asset_optimization.optimization.Optimizer"
      via: "import and instantiation"
      pattern: "Optimizer\\("
    - from: "tests/test_optimization.py"
      to: "tests/conftest.py"
      via: "shared fixtures"
      pattern: "@pytest.fixture"
    - from: "tests/test_optimization.py"
      to: "Portfolio.from_dataframe"
      via: "portfolio construction in tests"
      pattern: "Portfolio\\.from_dataframe"
---

<objective>
Create comprehensive test suite for optimization module.

Purpose: Verify greedy algorithm correctness, budget enforcement, edge cases, and API behavior.
Output: tests/test_optimization.py with organized test classes
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-optimization/04-CONTEXT.md
@.planning/phases/04-optimization/04-RESEARCH.md

# Dependencies
@.planning/phases/04-optimization/04-02-SUMMARY.md

# Pattern references
@tests/test_simulation.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for optimization</name>
  <files>tests/conftest.py</files>
  <action>
Add optimization-specific fixtures to conftest.py (if not already present):

```python
@pytest.fixture
def optimization_portfolio():
    """Portfolio with known failure probabilities for optimization testing.

    IMPORTANT: Use Portfolio.from_dataframe(), not Portfolio(df).
    Portfolio constructor accepts no arguments - must use factory method.
    """
    df = pd.DataFrame({
        'asset_id': ['A1', 'A2', 'A3', 'A4', 'A5'],
        'material': ['PVC', 'PVC', 'PVC', 'PVC', 'PVC'],
        'install_date': pd.to_datetime([
            '1980-01-01',  # ~45 years old, high risk
            '1990-01-01',  # ~35 years old, medium-high risk
            '2000-01-01',  # ~25 years old, medium risk
            '2010-01-01',  # ~15 years old, low risk
            '2020-01-01',  # ~5 years old, very low risk
        ]),
        'condition': [2, 3, 3, 4, 5],
        'diameter_mm': [100, 100, 100, 100, 100],
        'length_m': [100, 100, 100, 100, 100],
        'location': ['Zone1', 'Zone1', 'Zone1', 'Zone1', 'Zone1']
    })
    portfolio = Portfolio.from_dataframe(df)
    # Add age column
    portfolio._data['age'] = (pd.Timestamp.now() - portfolio.data['install_date']).dt.days / 365.25
    return portfolio


@pytest.fixture
def weibull_model():
    """WeibullModel with standard PVC parameters."""
    return WeibullModel({'PVC': (2.5, 50.0)})
```

Add necessary imports at top of conftest.py if not present:
- from asset_optimization import Portfolio, WeibullModel
  </action>
  <verify>
pytest tests/conftest.py --collect-only 2>&1 | grep -E "(optimization_portfolio|weibull_model)" && echo "Fixtures found"
  </verify>
  <done>
optimization_portfolio and weibull_model fixtures available for optimization tests
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive optimization test suite</name>
  <files>tests/test_optimization.py</files>
  <action>
Create tests/test_optimization.py with organized test classes following test_simulation.py pattern.

CRITICAL: Use `Portfolio.from_dataframe(df)` for ALL portfolio construction, NOT `Portfolio(df)`.
The Portfolio constructor accepts no arguments - factory methods are required.

```python
"""Tests for optimization module."""

import pytest
import pandas as pd
import numpy as np

from asset_optimization import Portfolio, WeibullModel
from asset_optimization.optimization import Optimizer, OptimizationResult
from asset_optimization.exceptions import OptimizationError


class TestOptimizerInit:
    """Tests for Optimizer initialization."""

    def test_default_strategy(self):
        """Default strategy is 'greedy'."""
        opt = Optimizer()
        assert opt.strategy == 'greedy'

    def test_default_min_risk_threshold(self):
        """Default min_risk_threshold is 0.0."""
        opt = Optimizer()
        assert opt.min_risk_threshold == 0.0

    def test_custom_strategy(self):
        """Can set custom strategy."""
        opt = Optimizer(strategy='milp')
        assert opt.strategy == 'milp'

    def test_custom_threshold(self):
        """Can set custom min_risk_threshold."""
        opt = Optimizer(min_risk_threshold=0.1)
        assert opt.min_risk_threshold == 0.1


class TestOptimizerFit:
    """Tests for Optimizer.fit() method."""

    def test_fit_returns_self(self, optimization_portfolio, weibull_model):
        """fit() returns self for method chaining."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        result = opt.fit(portfolio, weibull_model, budget=100000.0)
        assert result is opt

    def test_fit_sets_result_attribute(self, optimization_portfolio, weibull_model):
        """fit() sets result_ attribute."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)
        assert hasattr(opt, 'result_')
        assert isinstance(opt.result_, OptimizationResult)

    def test_result_property_before_fit_raises(self):
        """Accessing result before fit() raises AttributeError."""
        opt = Optimizer()
        with pytest.raises(AttributeError, match="not been fitted"):
            _ = opt.result

    def test_result_property_after_fit(self, optimization_portfolio, weibull_model):
        """result property returns result_ after fit()."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)
        assert opt.result is opt.result_

    def test_milp_strategy_raises(self, optimization_portfolio, weibull_model):
        """MILP strategy raises NotImplementedError."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer(strategy='milp')
        with pytest.raises(NotImplementedError, match="MILP"):
            opt.fit(portfolio, weibull_model, budget=100000.0)

    def test_unknown_strategy_raises(self, optimization_portfolio, weibull_model):
        """Unknown strategy raises ValueError."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer(strategy='unknown')
        with pytest.raises(ValueError, match="Unknown strategy"):
            opt.fit(portfolio, weibull_model, budget=100000.0)


class TestBudgetConstraint:
    """Tests for budget constraint enforcement."""

    def test_budget_never_exceeded(self, optimization_portfolio, weibull_model):
        """Total spent never exceeds budget."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        for budget in [1000, 5000, 10000, 50000, 100000, 500000]:
            opt = Optimizer()
            opt.fit(portfolio, weibull_model, budget=float(budget))
            assert opt.result.total_spent <= budget

    def test_zero_budget_empty_selections(self, optimization_portfolio, weibull_model):
        """Zero budget results in empty selections."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=0.0)
        assert len(opt.result.selections) == 0
        assert opt.result.total_spent == 0.0

    def test_budget_utilization_calculated(self, optimization_portfolio, weibull_model):
        """Budget utilization percentage is correctly calculated."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        expected_util = (opt.result.total_spent / 100000.0) * 100
        assert abs(opt.result.utilization_pct - expected_util) < 0.01


class TestGreedyRanking:
    """Tests for greedy selection algorithm."""

    def test_highest_risk_selected_first(self, optimization_portfolio, weibull_model):
        """Highest risk-to-cost ratio asset selected first (rank=1)."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        if len(opt.result.selections) > 0:
            # Oldest asset (A1) should have highest risk, should be rank 1
            first_selected = opt.result.selections[opt.result.selections['rank'] == 1]
            assert len(first_selected) == 1
            # A1 is oldest (1980), should be first
            assert first_selected.iloc[0]['asset_id'] == 'A1'

    def test_selections_ordered_by_rank(self, optimization_portfolio, weibull_model):
        """Selections have sequential rank values."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=200000.0)

        if len(opt.result.selections) > 1:
            ranks = opt.result.selections['rank'].tolist()
            assert ranks == list(range(1, len(ranks) + 1))

    def test_tie_breaking_oldest_first(self, weibull_model):
        """When risk-to-cost ratio is equal, oldest asset selected first."""
        # Create portfolio with same-age assets for tie scenario
        df = pd.DataFrame({
            'asset_id': ['A1', 'A2'],
            'material': ['PVC', 'PVC'],
            'install_date': pd.to_datetime(['1990-01-01', '2000-01-01']),
            'condition': [3, 3],
            'diameter_mm': [100, 100],
            'length_m': [100, 100],
            'location': ['Zone1', 'Zone1']
        })
        portfolio = Portfolio.from_dataframe(df)
        portfolio._data['age'] = (pd.Timestamp.now() - portfolio.data['install_date']).dt.days / 365.25
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        # A1 is older (1990 vs 2000), should be first
        if len(opt.result.selections) >= 2:
            first = opt.result.selections[opt.result.selections['rank'] == 1].iloc[0]
            assert first['asset_id'] == 'A1'


class TestMinRiskThreshold:
    """Tests for minimum risk threshold filtering."""

    def test_low_risk_assets_excluded(self, optimization_portfolio, weibull_model):
        """Assets below min_risk_threshold are not selected."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        # Get risk of youngest asset (A5, ~5 years old)
        a5_risk = portfolio.data[portfolio.data['asset_id'] == 'A5']['failure_probability'].iloc[0]

        # Set threshold above A5's risk
        opt = Optimizer(min_risk_threshold=a5_risk + 0.01)
        opt.fit(portfolio, weibull_model, budget=500000.0)

        selected_ids = opt.result.selections['asset_id'].tolist()
        assert 'A5' not in selected_ids

    def test_threshold_zero_includes_all(self, optimization_portfolio, weibull_model):
        """Threshold of 0 includes all assets (if budget allows)."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer(min_risk_threshold=0.0)
        opt.fit(portfolio, weibull_model, budget=500000.0)  # Large budget

        # Should select something
        assert len(opt.result.selections) > 0


class TestExclusionList:
    """Tests for asset exclusion functionality."""

    def test_excluded_assets_not_selected(self, optimization_portfolio, weibull_model):
        """Excluded asset IDs are not in selections."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=500000.0, exclusions=['A1', 'A2'])

        selected_ids = opt.result.selections['asset_id'].tolist()
        assert 'A1' not in selected_ids
        assert 'A2' not in selected_ids

    def test_empty_exclusion_list(self, optimization_portfolio, weibull_model):
        """Empty exclusion list excludes nothing."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt1 = Optimizer()
        opt1.fit(portfolio, weibull_model, budget=100000.0, exclusions=[])

        opt2 = Optimizer()
        opt2.fit(portfolio, weibull_model, budget=100000.0, exclusions=None)

        assert len(opt1.result.selections) == len(opt2.result.selections)


class TestOptimizationResult:
    """Tests for OptimizationResult dataclass."""

    def test_selections_dataframe_columns(self, optimization_portfolio, weibull_model):
        """Selections DataFrame has required columns."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        required_cols = ['asset_id', 'intervention_type', 'cost', 'risk_score', 'rank']
        for col in required_cols:
            assert col in opt.result.selections.columns

    def test_budget_summary_columns(self, optimization_portfolio, weibull_model):
        """Budget summary DataFrame has required columns."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        required_cols = ['budget', 'spent', 'remaining', 'utilization_pct']
        for col in required_cols:
            assert col in opt.result.budget_summary.columns

    def test_strategy_recorded(self, optimization_portfolio, weibull_model):
        """Strategy is recorded in result."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer(strategy='greedy')
        opt.fit(portfolio, weibull_model, budget=100000.0)
        assert opt.result.strategy == 'greedy'


class TestEdgeCases:
    """Tests for edge cases."""

    def test_empty_portfolio(self, weibull_model):
        """Empty portfolio returns empty selections."""
        df = pd.DataFrame({
            'asset_id': pd.Series([], dtype=str),
            'material': pd.Series([], dtype=str),
            'install_date': pd.Series([], dtype='datetime64[ns]'),
            'condition': pd.Series([], dtype=float),
            'diameter_mm': pd.Series([], dtype='Int64'),
            'length_m': pd.Series([], dtype=float),
            'location': pd.Series([], dtype=str),
        })
        # For empty DataFrame, bypass validation by directly setting _data
        portfolio = Portfolio.__new__(Portfolio)
        portfolio._data = df.assign(age=pd.Series([], dtype=float), failure_probability=pd.Series([], dtype=float))
        portfolio._quality_metrics = {}
        portfolio._n_assets = 0

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        assert len(opt.result.selections) == 0
        assert opt.result.total_spent == 0.0

    def test_single_asset(self, weibull_model):
        """Single asset portfolio works correctly."""
        df = pd.DataFrame({
            'asset_id': ['A1'],
            'material': ['PVC'],
            'install_date': pd.to_datetime(['1990-01-01']),
            'condition': [3],
            'diameter_mm': [100],
            'length_m': [100],
            'location': ['Zone1']
        })
        portfolio = Portfolio.from_dataframe(df)
        portfolio._data['age'] = (pd.Timestamp.now() - portfolio.data['install_date']).dt.days / 365.25
        portfolio._data = weibull_model.transform(portfolio.data)

        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100000.0)

        # Should select the single asset
        assert len(opt.result.selections) == 1

    def test_budget_too_small_for_any(self, optimization_portfolio, weibull_model):
        """Budget smaller than any intervention cost returns empty."""
        portfolio = optimization_portfolio
        portfolio._data = weibull_model.transform(portfolio.data)

        # Inspect is cheapest at $500
        opt = Optimizer()
        opt.fit(portfolio, weibull_model, budget=100.0)  # Less than Inspect cost

        assert len(opt.result.selections) == 0
```
  </action>
  <verify>
pytest tests/test_optimization.py -v --tb=short
  </verify>
  <done>
All optimization tests pass, covering constructor, fit(), budget constraint, greedy algorithm, threshold, exclusions, result structure, and edge cases
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_optimization.py -v` - all tests pass
2. `pytest tests/ -q` - full test suite passes (no regressions)
3. Test coverage includes all requirements: OPTM-01 (budget), OPTM-02 (greedy), OPTM-03 (pluggable), OPTM-04 (selection reporting)
</verification>

<success_criteria>
- All test classes organized by concern (Init, Fit, Budget, GreedyRanking, Threshold, Exclusions, Result, EdgeCases)
- All portfolio constructions use Portfolio.from_dataframe() (NOT Portfolio(df))
- Budget constraint tests verify never exceeded
- Greedy algorithm tests verify risk-to-cost ordering
- MILP and unknown strategy error tests pass
- Exclusion list tests verify correct filtering
- Threshold tests verify correct filtering
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-optimization/04-03-SUMMARY.md`
</output>
