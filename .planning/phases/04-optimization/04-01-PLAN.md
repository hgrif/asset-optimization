---
phase: 04-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/optimization/result.py
  - src/asset_optimization/exceptions.py
autonomous: true

must_haves:
  truths:
    - "OptimizationResult holds selections DataFrame and budget_summary DataFrame"
    - "OptimizationResult has total_spent and utilization_pct convenience properties"
    - "OptimizationError provides clear context for optimization failures"
  artifacts:
    - path: "src/asset_optimization/optimization/result.py"
      provides: "OptimizationResult dataclass"
      exports: ["OptimizationResult"]
    - path: "src/asset_optimization/exceptions.py"
      provides: "OptimizationError exception"
      contains: "class OptimizationError"
  key_links:
    - from: "src/asset_optimization/optimization/result.py"
      to: "pandas.DataFrame"
      via: "selections and budget_summary fields"
      pattern: "pd\\.DataFrame"
    - from: "src/asset_optimization/exceptions.py"
      to: "AssetOptimizationError"
      via: "exception inheritance"
      pattern: "class OptimizationError\\(AssetOptimizationError\\)"
---

<objective>
Create OptimizationResult dataclass and OptimizationError exception.

Purpose: Foundation for optimizer output -- result container following SimulationResult pattern, and error class following SimulationError pattern.
Output: result.py with OptimizationResult, updated exceptions.py with OptimizationError
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-optimization/04-CONTEXT.md
@.planning/phases/04-optimization/04-RESEARCH.md

# Pattern references
@src/asset_optimization/simulation/result.py
@src/asset_optimization/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OptimizationResult dataclass</name>
  <files>
    src/asset_optimization/optimization/__init__.py
    src/asset_optimization/optimization/result.py
  </files>
  <action>
Create optimization/ subpackage with result.py containing OptimizationResult dataclass.

1. Create `src/asset_optimization/optimization/` directory
2. Create `__init__.py` (empty for now, exports added in Plan 02)
3. Create `result.py` with:

```python
@dataclass
class OptimizationResult:
    """Results from optimization run.

    Attributes
    ----------
    selections : pd.DataFrame
        Selected interventions with columns:
        - asset_id: str
        - intervention_type: str ('Replace', 'Repair', 'Inspect')
        - cost: float
        - risk_score: float (P(failure) at current age)
        - rank: int (position in greedy selection order)
    budget_summary : pd.DataFrame
        Single-row DataFrame with columns:
        - budget: float (total annual budget)
        - spent: float (total cost of selected interventions)
        - remaining: float (budget - spent)
        - utilization_pct: float (spent / budget * 100)
    strategy : str
        Strategy used ('greedy', 'milp')
    """
    selections: pd.DataFrame
    budget_summary: pd.DataFrame
    strategy: str
```

Add convenience properties:
- `total_spent` -> float from budget_summary['spent']
- `utilization_pct` -> float from budget_summary['utilization_pct']

Add `__repr__` showing: strategy, assets selected count, total spent, utilization %

Follow SimulationResult pattern: non-frozen dataclass (DataFrames are mutable internally).
  </action>
  <verify>
python -c "from asset_optimization.optimization.result import OptimizationResult; import pandas as pd; r = OptimizationResult(pd.DataFrame(), pd.DataFrame({'budget':[100], 'spent':[50], 'remaining':[50], 'utilization_pct':[50.0]}), 'greedy'); print(r.total_spent, r.utilization_pct)"
  </verify>
  <done>
OptimizationResult instantiates with selections, budget_summary, strategy; convenience properties return correct values
  </done>
</task>

<task type="auto">
  <name>Task 2: Add OptimizationError to exceptions</name>
  <files>src/asset_optimization/exceptions.py</files>
  <action>
Add OptimizationError class inheriting from AssetOptimizationError (NOT Exception) to maintain package exception hierarchy:

```python
class OptimizationError(AssetOptimizationError):
    """Raised when optimization encounters an error.

    Attributes
    ----------
    message : str
        Human-readable error description.
    details : dict
        Additional error context (budget, strategy, etc.).
    """

    def __init__(self, message, details=None):
        self.message = message
        self.details = details or {}
        super().__init__(self._format_message())

    def _format_message(self):
        msg = f"Optimization error: {self.message}"
        if self.details:
            detail_str = ", ".join(f"{k}={v}" for k, v in self.details.items())
            msg += f" ({detail_str})"
        return msg
```

IMPORTANT: Inherit from AssetOptimizationError, not Exception. This maintains the package exception hierarchy so users can catch all package exceptions with `except AssetOptimizationError`.

Place after SimulationError class (maintain alphabetical-ish grouping by domain).
  </action>
  <verify>
python -c "from asset_optimization.exceptions import OptimizationError, AssetOptimizationError; e = OptimizationError('test', {'budget': 1000}); print(str(e)); assert isinstance(e, AssetOptimizationError), 'Must inherit from AssetOptimizationError'"
  </verify>
  <done>
OptimizationError raises with message and optional details dict, formatted like SimulationError, and inherits from AssetOptimizationError
  </done>
</task>

</tasks>

<verification>
1. `python -c "from asset_optimization.optimization.result import OptimizationResult"` succeeds
2. `python -c "from asset_optimization.exceptions import OptimizationError"` succeeds
3. `python -c "from asset_optimization.exceptions import OptimizationError, AssetOptimizationError; assert isinstance(OptimizationError('x'), AssetOptimizationError)"` verifies hierarchy
4. All existing tests still pass: `pytest tests/ -q`
</verification>

<success_criteria>
- OptimizationResult dataclass exists with selections, budget_summary, strategy fields
- OptimizationResult has total_spent and utilization_pct properties
- OptimizationError exists with message and details formatting
- OptimizationError inherits from AssetOptimizationError (not Exception)
- Existing test suite passes (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-optimization/04-01-SUMMARY.md`
</output>
