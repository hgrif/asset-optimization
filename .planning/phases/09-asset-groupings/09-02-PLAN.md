---
phase: 09-asset-groupings
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/constraints.py
  - src/asset_optimization/optimization/optimizer.py
  - tests/test_optimization.py
  - tests/test_constraints.py
autonomous: true

must_haves:
  truths:
    - "User can add group coherence constraint via ConstraintSet.add_group_coherence()"
    - "Optimizer respects group constraints by selecting all or none from each group"
    - "Ungrouped assets (null group_id) are treated as singletons"
    - "Existing optimization without group constraint works unchanged"
  artifacts:
    - path: "src/asset_optimization/constraints.py"
      provides: "add_group_coherence() method on ConstraintSet"
      contains: "add_group_coherence"
    - path: "src/asset_optimization/optimization/optimizer.py"
      provides: "_enforce_group_coherence() method and integration in solve()"
      contains: "_enforce_group_coherence"
    - path: "tests/test_optimization.py"
      provides: "Tests for group coherence in optimizer"
      contains: "group_coherence"
    - path: "tests/test_constraints.py"
      provides: "Tests for add_group_coherence constraint builder"
      contains: "group_coherence"
  key_links:
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "src/asset_optimization/constraints.py"
      via: "constraints.find('group_coherence') in solve()"
      pattern: "find\(\"group_coherence\"\)"
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "_enforce_group_coherence"
      via: "called after ranking, before budget selection"
      pattern: "_enforce_group_coherence"
---

<objective>
Implement group coherence constraint for the optimizer so grouped assets are selected all-or-nothing.

Purpose: Enforce operational bundling by selecting entire groups as a unit while preserving existing behavior for ungrouped assets.

Output: ConstraintSet.add_group_coherence(), Optimizer group-aware ordering and selection, and comprehensive tests.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-asset-groupings/09-RESEARCH.md
@src/asset_optimization/constraints.py
@src/asset_optimization/optimization/optimizer.py
@tests/test_optimization.py
@tests/test_constraints.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add group_coherence to ConstraintSet</name>
  <files>
    src/asset_optimization/constraints.py
    tests/test_constraints.py
  </files>
  <action>
Add a new method to ConstraintSet:

```python
def add_group_coherence(self, group_column: str = "group_id") -> "ConstraintSet":
    """Require all assets in a group to be selected together."""
```

Implementation:
- Validate `group_column` is a non-empty string.
- Call `self._add("group_coherence", group_column=group_column)` and return self.

Tests in `tests/test_constraints.py`:
1. `test_add_group_coherence_default` -- default column is `group_id`.
2. `test_add_group_coherence_custom_column` -- custom column stored.
3. `test_add_group_coherence_chaining` -- fluent API with add_budget_limit.
4. `test_find_group_coherence` -- `constraints.find("group_coherence")` returns the constraint.
  </action>
  <verify>
Run `uv run pytest tests/test_constraints.py -x -v`.
  </verify>
  <done>ConstraintSet supports add_group_coherence() with tests.</done>
</task>

<task type="auto">
  <name>Task 2: Enforce group coherence in Optimizer</name>
  <files>
    src/asset_optimization/optimization/optimizer.py
    tests/test_optimization.py
  </files>
  <action>
**In optimizer.py:**

1. Add `_enforce_group_coherence` static method:

```python
@staticmethod
def _enforce_group_coherence(
    ranked_candidates: pd.DataFrame,
    constraint: Constraint,
) -> pd.DataFrame:
```

Logic:
- Extract `group_column` from constraint params (default "group_id").
- If missing in candidates, return unchanged.
- Fill null group ids with unique singleton IDs (use asset_id + "_singleton").
- Aggregate to group level (`direct_cost` sum, `expected_benefit` sum), compute group-level benefit/cost ratio.
- Sort groups by ratio desc then expected_benefit desc.
- Expand back to asset level preserving group ordering (group assets contiguous).

2. Modify `solve()`:
After `ranked = self._prepare_ranked_candidates(candidates)` and before `_select_with_budget`, add:

```python
# Apply group coherence constraint if present
group_constraints = constraints.find("group_coherence")
if group_constraints:
    ranked = self._enforce_group_coherence(ranked, group_constraints[-1])
    group_column = group_constraints[-1].params.get("group_column", "group_id")
else:
    group_column = None

selected_actions, remaining_budget = self._select_with_budget(
    ranked, budget_limit, group_column=group_column
)
```

3. Update `_select_with_budget` to accept `group_column: str | None = None` and enforce all-or-nothing:
- If `group_column` is None or not in columns, keep existing behavior.
- Otherwise, fill null group ids with singleton identifiers.
- Pre-compute group total costs.
- Iterate through ranked candidates and select/skip entire groups based on remaining budget.
- Ensure a group is decided once (track seen groups).

**In tests/test_optimization.py, add tests:**
1. `test_group_coherence_selects_complete_groups`
2. `test_group_coherence_skips_unaffordable_group`
3. `test_group_coherence_null_group_ids_as_singletons`
4. `test_group_coherence_no_group_column`
5. `test_group_coherence_with_budget_limit`
6. `test_optimizer_without_group_coherence_unchanged`

Use `ObjectiveBuilder().add_expected_risk_reduction().add_total_cost(weight=-1.0).build()` for objectives (no `minimize_cost()` in current API).
  </action>
  <verify>
Run `uv run pytest tests/test_optimization.py -x -v`.
Run `uv run pytest tests/test_constraints.py -x -v`.
  </verify>
  <done>Optimizer enforces group coherence and tests cover grouped, singleton, and no-op behaviors.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_optimization.py tests/test_constraints.py -v`
2. `uv run pytest -x -q`
3. `make lint`
4. `make docs`
5. No regressions in existing optimization behavior
</verification>

<success_criteria>
- ConstraintSet has add_group_coherence(group_column="group_id")
- Optimizer applies group coherence when present
- _select_with_budget respects group boundaries
- 6+ tests cover grouped selection, skipping, singletons, and no-op
- All quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-asset-groupings/09-02-SUMMARY.md`
</output>
