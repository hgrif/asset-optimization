---
phase: 09-asset-groupings
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/constraints.py
  - src/asset_optimization/optimization/optimizer.py
  - tests/test_optimization.py
  - tests/test_constraints.py
autonomous: true

must_haves:
  truths:
    - "User can add group coherence constraint via ConstraintSet.add_group_coherence()"
    - "Optimizer respects group constraints by selecting all or none from each group"
    - "Ungrouped assets (null group_id) are treated as singletons and selected individually"
    - "Existing optimization without group constraint works unchanged"
  artifacts:
    - path: "src/asset_optimization/constraints.py"
      provides: "add_group_coherence() method on ConstraintSet"
      contains: "add_group_coherence"
    - path: "src/asset_optimization/optimization/optimizer.py"
      provides: "_enforce_group_coherence() method and integration in solve()"
      contains: "_enforce_group_coherence"
    - path: "tests/test_optimization.py"
      provides: "Tests for group coherence in optimizer"
      contains: "group_coherence"
    - path: "tests/test_constraints.py"
      provides: "Tests for add_group_coherence constraint builder"
      contains: "group_coherence"
  key_links:
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "src/asset_optimization/constraints.py"
      via: "constraints.find('group_coherence') in solve()"
      pattern: "find.*group_coherence"
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "_enforce_group_coherence"
      via: "called after ranking, before budget selection"
      pattern: "_enforce_group_coherence"
---

<objective>
Implement group coherence constraint for the optimizer so that grouped assets must be selected together (all-or-nothing).

Purpose: When assets are in a group (e.g., pipes in the same trench), it is operationally efficient to intervene on all of them together. The group coherence constraint enforces this all-or-nothing selection at the optimizer level.

Output: ConstraintSet.add_group_coherence() method, Optimizer._enforce_group_coherence() logic, and comprehensive tests.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-asset-groupings/09-RESEARCH.md
@src/asset_optimization/constraints.py
@src/asset_optimization/optimization/optimizer.py
@tests/test_optimization.py
@tests/test_constraints.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add group_coherence to ConstraintSet</name>
  <files>
    src/asset_optimization/constraints.py
    tests/test_constraints.py
  </files>
  <action>
**In constraints.py:**

Add a new method to ConstraintSet:

```python
def add_group_coherence(self, group_column: str = "group_id") -> "ConstraintSet":
    """Require all assets in a group to be selected together.

    When this constraint is active, the optimizer must select either ALL
    assets in a group or NONE. Assets with null group_id are treated as
    singletons.

    Parameters
    ----------
    group_column : str, default='group_id'
        DataFrame column identifying groups.

    Returns
    -------
    ConstraintSet
        Self with group coherence constraint added (fluent API).
    """
```

Implementation: Validate that group_column is a non-empty string. Call `self._add("group_coherence", group_column=group_column)` and return self.

**In tests/test_constraints.py, add tests:**

1. `test_add_group_coherence_default` -- ConstraintSet().add_group_coherence() creates constraint with kind='group_coherence' and params={'group_column': 'group_id'}.
2. `test_add_group_coherence_custom_column` -- ConstraintSet().add_group_coherence(group_column='zone_id') stores 'zone_id'.
3. `test_add_group_coherence_chaining` -- Can chain with add_budget_limit: `ConstraintSet().add_budget_limit(1000).add_group_coherence()` has 2 constraints.
4. `test_find_group_coherence` -- `constraints.find('group_coherence')` returns the constraint.

Follow existing test patterns in the file.
  </action>
  <verify>
Run `uv run pytest tests/test_constraints.py -x -v` -- all tests pass.
  </verify>
  <done>ConstraintSet has add_group_coherence() method with fluent API, default group_column='group_id', and 4 tests verifying behavior.</done>
</task>

<task type="auto">
  <name>Task 2: Implement group coherence enforcement in Optimizer</name>
  <files>
    src/asset_optimization/optimization/optimizer.py
    tests/test_optimization.py
  </files>
  <action>
**In optimizer.py:**

1. Add a `_enforce_group_coherence` static method to Optimizer:

```python
@staticmethod
def _enforce_group_coherence(
    ranked_candidates: pd.DataFrame,
    constraint: "Constraint",
) -> pd.DataFrame:
```

Logic:
- Extract group_column from constraint.params (default 'group_id').
- If group_column not in candidates.columns, return unchanged.
- Fill null group_ids with unique singleton identifiers (use asset_id + '_singleton' pattern).
- Aggregate candidates to group level: sum direct_cost and expected_benefit per group.
- Calculate group-level benefit_cost_ratio = expected_benefit / direct_cost (handle zero-cost with np.inf).
- Sort groups by benefit_cost_ratio descending, then expected_benefit descending.
- Expand back to asset level preserving group ordering. All assets in a group must be contiguous in the output.
- Drop temporary columns (_group_id_filled etc.).
- Return re-ordered candidates.

2. Modify `solve()` method:

After `ranked = self._prepare_ranked_candidates(candidates)` and BEFORE `selected_actions, remaining_budget = self._select_with_budget(ranked, budget_limit)`, add:

```python
# Apply group coherence constraint if present
group_constraints = constraints.find("group_coherence")
if group_constraints:
    ranked = self._enforce_group_coherence(ranked, group_constraints[-1])
```

3. Modify `_select_with_budget` to handle group coherence:

When group coherence is active, the budget selection must respect group boundaries. If an asset is from a group (non-singleton), all group members must fit in the remaining budget or none are selected.

Approach: In _select_with_budget, add an optional `group_column` parameter (default None). When set:
- Track which groups have been started.
- When encountering a grouped asset, check if the ENTIRE group's cost fits in remaining budget.
- If yes, select all group members. If no, skip all group members.
- Singletons are selected individually as before.

Alternative simpler approach (preferred): Since _enforce_group_coherence already orders assets so group members are contiguous, modify _select_with_budget to detect contiguous groups and select/skip them as a unit. Add a `group_column` parameter to _select_with_budget. When provided:
- Before iterating, pre-compute group total costs.
- When hitting a grouped asset, look up group total cost. If it fits remaining budget, select all members and deduct total cost. If not, skip all members. Track which groups were decided.

Pass group_column from solve() to _select_with_budget when group_coherence constraint is active.

Import Constraint type at top of file if needed: `from asset_optimization.constraints import Constraint, ConstraintSet`

**In tests/test_optimization.py, add tests:**

1. `test_group_coherence_selects_complete_groups` -- 5 assets in 2 groups (A: 2 assets, B: 2 assets) plus 1 singleton. Budget allows group A ($20) + group B ($30) = $50. Verify all 4 grouped assets are selected together.

2. `test_group_coherence_skips_unaffordable_group` -- Group A costs $60 total, budget is $50. Verify group A is entirely skipped, singleton assets within budget are selected instead.

3. `test_group_coherence_null_group_ids_as_singletons` -- Assets with null group_id are selected individually based on benefit/cost ratio, not as a group.

4. `test_group_coherence_no_group_column` -- Candidates without group_id column. Group coherence constraint is present but has no effect (graceful no-op).

5. `test_group_coherence_with_budget_limit` -- Combine add_budget_limit and add_group_coherence. Verify both constraints are respected simultaneously.

6. `test_optimizer_without_group_coherence_unchanged` -- Existing optimization without group_coherence works exactly as before (regression test).

Use ObjectiveBuilder().minimize_cost().build() for objective. Use Optimizer() default. Follow existing test patterns.
  </action>
  <verify>
Run `uv run pytest tests/test_optimization.py -x -v` -- all tests pass including new group coherence tests.
Run `uv run pytest tests/test_constraints.py -x -v` -- constraint tests pass.
Run `uv run pytest -x -q` -- full test suite passes (no regressions).
Run `make lint` -- passes.
  </verify>
  <done>
Optimizer._enforce_group_coherence() re-ranks candidates at group level. _select_with_budget handles group-level all-or-nothing selection. 6 new tests verify: complete group selection, unaffordable group skipping, null group_id handling, missing column graceful handling, combined constraints, and no-regression without constraint.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_optimization.py tests/test_constraints.py -v` -- all tests pass
2. `uv run pytest -x -q` -- full test suite passes
3. `make lint` -- no lint errors
4. ConstraintSet.add_group_coherence() works with fluent API chaining
5. Optimizer selects all-or-nothing for grouped assets
6. Singletons (null group_id) unaffected by group constraint
7. No regressions in existing optimization behavior
</verification>

<success_criteria>
- ConstraintSet has add_group_coherence(group_column='group_id') method
- Optimizer.solve() detects and applies group_coherence constraint
- _enforce_group_coherence re-ranks at group level
- _select_with_budget respects group boundaries (all-or-nothing)
- 10+ new tests across constraints and optimization
- All existing tests pass without modification
- make lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/09-asset-groupings/09-02-SUMMARY.md`
</output>
