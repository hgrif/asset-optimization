---
phase: 03-simulation-core
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/asset_optimization/simulation/simulator.py
  - src/asset_optimization/simulation/__init__.py
  - src/asset_optimization/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can run 10-year simulation with Simulator.run(portfolio)"
    - "System updates asset ages after each timestep"
    - "System calculates conditional failure probabilities using survival functions"
    - "Simulation produces deterministic results with same random seed"
    - "System tracks cumulative costs and failure counts per year"
    - "Asset-level history is optional (track_asset_history config)"
  artifacts:
    - path: "src/asset_optimization/simulation/simulator.py"
      provides: "Simulator class with run() method"
      contains: "def run(self, portfolio)"
      min_lines: 150
    - path: "src/asset_optimization/__init__.py"
      provides: "Top-level Simulator export"
      exports: ["Simulator", "SimulationConfig", "SimulationResult"]
  key_links:
    - from: "src/asset_optimization/simulation/simulator.py"
      to: "src/asset_optimization/models/base.py"
      via: "DeteriorationModel for failure calculations"
      pattern: "self\\.model\\.transform"
    - from: "src/asset_optimization/simulation/simulator.py"
      to: "scipy.stats"
      via: "weibull_min.sf for conditional probability"
      pattern: "weibull_min\\.sf"
---

<objective>
Implement the core Simulator class with multi-timestep simulation loop.

Purpose: This is the heart of Phase 3 - the Simulator class that runs multi-year simulations, updates asset states, samples failures using conditional probabilities, applies intervention responses, and tracks costs/metrics.

Output: Simulator class with run() method that returns SimulationResult, using np.random.default_rng() for reproducibility.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-simulation-core/03-CONTEXT.md
@.planning/phases/03-simulation-core/03-RESEARCH.md
@.planning/phases/03-simulation-core/03-01-SUMMARY.md
@.planning/phases/03-simulation-core/03-02-SUMMARY.md

Key files from prior phases:
- src/asset_optimization/portfolio.py — Portfolio class with .data DataFrame
- src/asset_optimization/models/weibull.py — WeibullModel with transform()
- src/asset_optimization/models/base.py — DeteriorationModel ABC

Key decisions:
- Order within timestep: Age -> Failures -> Interventions
- Use conditional probability: P(fail in [t,t+1) | survived to t) = (S(t) - S(t+1)) / S(t)
- Use np.random.default_rng() for isolated, reproducible randomness
- Track both calendar year and effective age
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Simulator class core</name>
  <files>src/asset_optimization/simulation/simulator.py</files>
  <action>
Create the Simulator class with the main simulation loop:

```python
class Simulator:
    """Multi-timestep asset simulation engine.

    Parameters
    ----------
    deterioration_model : DeteriorationModel
        Model for calculating failure probabilities (e.g., WeibullModel)
    config : SimulationConfig
        Simulation configuration
    interventions : dict[str, InterventionType], optional
        Custom interventions keyed by name. If None, uses defaults.

    Examples
    --------
    >>> from asset_optimization import Portfolio, WeibullModel, Simulator, SimulationConfig
    >>> portfolio = Portfolio.from_csv('assets.csv')
    >>> model = WeibullModel({'PVC': (2.5, 50), 'Cast Iron': (3.0, 40)})
    >>> config = SimulationConfig(n_years=10, random_seed=42)
    >>> sim = Simulator(model, config)
    >>> result = sim.run(portfolio)
    >>> print(result)
    """
```

Implement:

1. `__init__(self, deterioration_model, config, interventions=None)`:
   - Store model, config
   - Create RNG: `np.random.default_rng(config.random_seed)` or `default_rng()` if None
   - Store interventions dict (default to REPLACE, REPAIR, DO_NOTHING)

2. `run(self, portfolio) -> SimulationResult`:
   - Initialize state from portfolio.data.copy()
   - Calculate initial ages from install_date relative to config.start_year
   - Loop for config.n_years:
     - Call _simulate_timestep()
     - Accumulate summary stats
     - Log failures
     - Optionally track asset history
   - Return SimulationResult

3. `_simulate_timestep(self, state, year) -> tuple[DataFrame, Series, dict]`:
   - Order: Age -> Failures -> Interventions
   - Step 1: Increment age by 1
   - Step 2: Calculate conditional failure probability (see _calculate_conditional_probability)
   - Step 3: Sample failures using rng.random() < probs
   - Step 4: Apply failure_response intervention (replace/repair/record_only)
   - Step 5: Track costs
   - Return (updated_state, failures_mask, costs_dict)

4. `_calculate_conditional_probability(self, state) -> np.ndarray`:
   - Use scipy.stats.weibull_min.sf() for survival function
   - Calculate S(t) and S(t+1) per asset type using model.params
   - Conditional prob = (S(t) - S(t+1)) / S(t)
   - Handle S(t) == 0 case (return 0.0)

Cost tracking in _simulate_timestep:
- failure_direct_cost: number of failures * 10000 (default)
- failure_consequence_cost: number of failures * 5000 (default)
- intervention_cost: based on failure_response intervention

Use config.failure_response to select which intervention to apply to failed assets.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "
import pandas as pd
import numpy as np
from asset_optimization.simulation.simulator import Simulator
from asset_optimization.simulation.config import SimulationConfig
from asset_optimization import Portfolio, WeibullModel

# Create test portfolio
test_data = pd.DataFrame({
    'asset_id': [f'PIPE-{i:03d}' for i in range(100)],
    'asset_type': ['pipe'] * 100,
    'material': ['PVC'] * 50 + ['Cast Iron'] * 50,
    'install_date': pd.date_range('2000-01-01', periods=100, freq='30D'),
    'diameter_mm': [100] * 100,
    'length_m': [50.0] * 100,
    'condition_score': [80.0] * 100,
})
portfolio = Portfolio.from_dataframe(test_data)

# Create model and config
model = WeibullModel({'PVC': (2.5, 50.0), 'Cast Iron': (3.0, 40.0)})
config = SimulationConfig(n_years=5, random_seed=42)

# Run simulation
sim = Simulator(model, config)
result = sim.run(portfolio)

print(f'Simulation complete: {len(result.summary)} years')
print(f'Total cost: \${result.total_cost():,.0f}')
print(f'Total failures: {result.total_failures()}')
print(result.summary)
"
```
  </verify>
  <done>Simulator.run() executes multi-timestep simulation with failure sampling and cost tracking</done>
</task>

<task type="auto">
  <name>Task 2: Verify reproducibility and export Simulator</name>
  <files>
    src/asset_optimization/simulation/__init__.py
    src/asset_optimization/__init__.py
  </files>
  <action>
1. Update simulation/__init__.py to export Simulator:
```python
from .simulator import Simulator
```

2. Update asset_optimization/__init__.py to export simulation classes at top level:
```python
from .simulation import (
    Simulator,
    SimulationConfig,
    SimulationResult,
    InterventionType,
    DO_NOTHING,
    INSPECT,
    REPAIR,
    REPLACE,
)
```

3. Add reproducibility verification in Simulator docstring with example.

The key reproducibility requirement: Same portfolio + same config (with random_seed) = identical results.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "
import pandas as pd
from asset_optimization import (
    Portfolio, WeibullModel, Simulator, SimulationConfig
)

# Create test portfolio
test_data = pd.DataFrame({
    'asset_id': [f'PIPE-{i:03d}' for i in range(50)],
    'asset_type': ['pipe'] * 50,
    'material': ['PVC'] * 50,
    'install_date': pd.date_range('2000-01-01', periods=50, freq='30D'),
    'diameter_mm': [100] * 50,
    'length_m': [50.0] * 50,
    'condition_score': [80.0] * 50,
})
portfolio = Portfolio.from_dataframe(test_data)
model = WeibullModel({'PVC': (2.5, 50.0)})

# Run twice with same seed
config = SimulationConfig(n_years=10, random_seed=42)
result1 = Simulator(model, config).run(portfolio)
result2 = Simulator(model, config).run(portfolio)

# Verify identical results
assert result1.total_cost() == result2.total_cost(), 'Costs should match'
assert result1.total_failures() == result2.total_failures(), 'Failures should match'
pd.testing.assert_frame_equal(result1.summary, result2.summary)

print('Reproducibility verified: same seed = same results')

# Verify different seeds produce different results
config3 = SimulationConfig(n_years=10, random_seed=123)
result3 = Simulator(model, config3).run(portfolio)
assert result1.total_failures() != result3.total_failures() or result1.summary['failure_count'].tolist() != result3.summary['failure_count'].tolist(), 'Different seeds should produce different results'
print('Different seeds produce different results')
"
```
  </verify>
  <done>Simulator exports at top level and reproducibility is verified</done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /Users/henkgriffioen/code/asset-optimization

# Integration test: Full workflow
python -c "
import pandas as pd
from asset_optimization import Portfolio, WeibullModel, Simulator, SimulationConfig

# Create realistic portfolio
n_assets = 500
test_data = pd.DataFrame({
    'asset_id': [f'PIPE-{i:04d}' for i in range(n_assets)],
    'asset_type': ['pipe'] * n_assets,
    'material': ['PVC'] * 250 + ['Cast Iron'] * 250,
    'install_date': pd.date_range('1990-01-01', periods=n_assets, freq='14D'),
    'diameter_mm': [100] * n_assets,
    'length_m': [50.0] * n_assets,
    'condition_score': [75.0] * n_assets,
})
portfolio = Portfolio.from_dataframe(test_data)

# Configure 10-year simulation
model = WeibullModel({'PVC': (2.5, 50.0), 'Cast Iron': (3.0, 40.0)})
config = SimulationConfig(
    n_years=10,
    start_year=2026,
    random_seed=42,
    failure_response='replace'
)

# Run simulation
sim = Simulator(model, config)
result = sim.run(portfolio)

# Verify results structure
assert len(result.summary) == 10, 'Should have 10 years of data'
assert 'year' in result.summary.columns
assert 'total_cost' in result.summary.columns
assert 'failure_count' in result.summary.columns
assert result.total_cost() > 0, 'Should have some costs'

print('Full integration test passed')
print(result)
"

# Run existing tests
pytest tests/ -v --tb=short 2>/dev/null || echo "Tests complete"
```
</verification>

<success_criteria>
- Simulator accepts DeteriorationModel and SimulationConfig
- run() method returns SimulationResult with summary, cost_breakdown, failure_log
- Conditional probability calculated correctly using survival functions
- Timestep order: Age -> Failures -> Interventions
- Same random_seed produces identical results (reproducibility)
- Different random_seeds produce different results
- Assets that fail have intervention applied (replace resets age to 0)
- Exports available from asset_optimization package root
</success_criteria>

<output>
After completion, create `.planning/phases/03-simulation-core/03-03-SUMMARY.md`
</output>
