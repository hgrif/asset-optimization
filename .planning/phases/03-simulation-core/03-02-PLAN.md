---
phase: 03-simulation-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/simulation/interventions.py
  - src/asset_optimization/simulation/__init__.py
autonomous: true

must_haves:
  truths:
    - "System provides DoNothing, Inspect, Repair, Replace intervention types"
    - "Each intervention type has name, cost, and age_effect"
    - "Replace resets age to 0, Repair reduces age, DoNothing leaves age unchanged"
    - "User can create custom interventions with configurable costs and effects"
  artifacts:
    - path: "src/asset_optimization/simulation/interventions.py"
      provides: "InterventionType dataclass and predefined interventions"
      contains: "class InterventionType"
    - path: "src/asset_optimization/simulation/__init__.py"
      provides: "Intervention exports"
      exports: ["InterventionType", "DO_NOTHING", "INSPECT", "REPAIR", "REPLACE"]
  key_links:
    - from: "src/asset_optimization/simulation/interventions.py"
      to: "dataclasses"
      via: "frozen dataclass for intervention definition"
      pattern: "@dataclass(frozen=True)"
---

<objective>
Create intervention type definitions with configurable costs and state effects.

Purpose: Define the four required intervention types (DoNothing, Inspect, Repair, Replace) as reusable dataclasses with pluggable age effects. This enables the Simulator to apply interventions uniformly.

Output: InterventionType dataclass, predefined intervention constants (DO_NOTHING, INSPECT, REPAIR, REPLACE), and utility functions for applying interventions.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-simulation-core/03-CONTEXT.md
@.planning/phases/03-simulation-core/03-RESEARCH.md

Key decisions from context:
- Replace: Resets effective age to 0, with option to upgrade asset type
- Repair: Configurable age reduction per repair type
- Inspect: Triggers follow-up actions (simplified for v1)
- DoNothing: No cost, no state change
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InterventionType dataclass</name>
  <files>src/asset_optimization/simulation/interventions.py</files>
  <action>
Create the intervention type dataclass:

1. Create `interventions.py` with:

```python
from dataclasses import dataclass
from typing import Callable, Optional

@dataclass(frozen=True)
class InterventionType:
    """Configuration for an intervention type.

    Attributes
    ----------
    name : str
        Intervention name (e.g., 'Replace', 'Repair')
    cost : float
        Direct cost to perform intervention
    age_effect : Callable[[float], float]
        Function: old_age -> new_age
        Examples:
        - Replace: lambda age: 0.0
        - Repair: lambda age: max(0.0, age - 5.0)
        - DoNothing: lambda age: age
    consequence_cost : float
        Additional cost for failures (service disruption)
    upgrade_type : str, optional
        New asset type after intervention (for Replace with upgrade)
    """
    name: str
    cost: float
    age_effect: Callable[[float], float]
    consequence_cost: float = 0.0
    upgrade_type: Optional[str] = None

    def apply_age_effect(self, age: float) -> float:
        """Apply age effect and return new age."""
        return self.age_effect(age)

    def total_cost(self) -> float:
        """Total cost including consequence cost."""
        return self.cost + self.consequence_cost
```

2. Add validation in __post_init__:
   - cost >= 0
   - consequence_cost >= 0
   - name is non-empty string

3. Create predefined intervention constants:
   - DO_NOTHING: cost=0, age unchanged
   - INSPECT: cost=500 (baseline), age unchanged (v1: no follow-up logic)
   - REPAIR: cost=5000, age reduced by 5 years (clamped to 0)
   - REPLACE: cost=50000, age reset to 0

Note: These are defaults. Users create custom InterventionType instances for their specific costs.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "
from asset_optimization.simulation.interventions import (
    InterventionType, DO_NOTHING, INSPECT, REPAIR, REPLACE
)

# Test predefined interventions
print(f'DO_NOTHING: cost={DO_NOTHING.cost}, age(10)={DO_NOTHING.apply_age_effect(10)}')
print(f'INSPECT: cost={INSPECT.cost}, age(10)={INSPECT.apply_age_effect(10)}')
print(f'REPAIR: cost={REPAIR.cost}, age(10)={REPAIR.apply_age_effect(10)}, age(3)={REPAIR.apply_age_effect(3)}')
print(f'REPLACE: cost={REPLACE.cost}, age(10)={REPLACE.apply_age_effect(10)}')

# Test custom intervention
custom = InterventionType(
    name='HeavyRepair',
    cost=15000.0,
    age_effect=lambda age: max(0.0, age - 10.0)
)
print(f'Custom: cost={custom.cost}, age(25)={custom.apply_age_effect(25)}')
"
```
  </verify>
  <done>InterventionType dataclass created with predefined DO_NOTHING, INSPECT, REPAIR, REPLACE</done>
</task>

<task type="auto">
  <name>Task 2: Export interventions from simulation package</name>
  <files>src/asset_optimization/simulation/__init__.py</files>
  <action>
Update the simulation package __init__.py to export intervention types:

1. Add imports:
```python
from .interventions import (
    InterventionType,
    DO_NOTHING,
    INSPECT,
    REPAIR,
    REPLACE,
)
```

2. Add to __all__ list

Note: If __init__.py doesn't exist yet from 03-01, create it with both config and intervention exports.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "
from asset_optimization.simulation import (
    InterventionType, DO_NOTHING, INSPECT, REPAIR, REPLACE
)
print('All intervention exports work')
print(f'Available: {[DO_NOTHING.name, INSPECT.name, REPAIR.name, REPLACE.name]}')
"
```
  </verify>
  <done>All intervention types export from asset_optimization.simulation</done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /Users/henkgriffioen/code/asset-optimization

# Full import test
python -c "
from asset_optimization.simulation import (
    InterventionType, DO_NOTHING, INSPECT, REPAIR, REPLACE
)

# Verify all four types have correct effects
assert DO_NOTHING.apply_age_effect(10.0) == 10.0, 'DoNothing should preserve age'
assert REPLACE.apply_age_effect(10.0) == 0.0, 'Replace should reset to 0'
assert REPAIR.apply_age_effect(10.0) == 5.0, 'Repair should reduce by 5'
assert REPAIR.apply_age_effect(3.0) == 0.0, 'Repair should clamp to 0'

print('All intervention types verified')
"
```
</verification>

<success_criteria>
- InterventionType is frozen dataclass with name, cost, age_effect, consequence_cost, upgrade_type
- DO_NOTHING, INSPECT, REPAIR, REPLACE predefined with appropriate defaults
- age_effect functions correctly transform ages (Replace->0, Repair->reduced, DoNothing->unchanged)
- Users can create custom interventions with InterventionType()
- All exports accessible from asset_optimization.simulation
</success_criteria>

<output>
After completion, create `.planning/phases/03-simulation-core/03-02-SUMMARY.md`
</output>
