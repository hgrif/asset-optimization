---
phase: 03-simulation-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/simulation/__init__.py
  - src/asset_optimization/simulation/config.py
  - src/asset_optimization/simulation/result.py
  - src/asset_optimization/exceptions.py
autonomous: true

must_haves:
  truths:
    - "SimulationConfig accepts n_years, start_year, random_seed, track_asset_history, failure_response"
    - "SimulationConfig validates n_years > 0 and failure_response in allowed values"
    - "SimulationResult provides summary DataFrame, failure_log DataFrame, cost_breakdown DataFrame"
    - "SimulationResult has total_cost() and total_failures() convenience methods"
  artifacts:
    - path: "src/asset_optimization/simulation/config.py"
      provides: "SimulationConfig dataclass"
      contains: "@dataclass(frozen=True)"
    - path: "src/asset_optimization/simulation/result.py"
      provides: "SimulationResult dataclass"
      contains: "def total_cost"
    - path: "src/asset_optimization/simulation/__init__.py"
      provides: "Module exports"
      exports: ["SimulationConfig", "SimulationResult"]
  key_links:
    - from: "src/asset_optimization/simulation/config.py"
      to: "dataclasses"
      via: "frozen dataclass with validation"
      pattern: "def __post_init__"
---

<objective>
Create simulation configuration and result dataclasses for the multi-timestep simulation engine.

Purpose: Establish the input/output contracts for the Simulator before implementing the core logic. This follows the pattern used in Phase 2 where we defined the ABC interface before implementation.

Output: SimulationConfig (immutable configuration), SimulationResult (structured output with DataFrames), and simulation-specific exceptions.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-simulation-core/03-CONTEXT.md
@.planning/phases/03-simulation-core/03-RESEARCH.md

Key references:
- src/asset_optimization/exceptions.py — existing exception patterns
- src/asset_optimization/models/base.py — established dataclass patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SimulationConfig dataclass</name>
  <files>
    src/asset_optimization/simulation/__init__.py
    src/asset_optimization/simulation/config.py
  </files>
  <action>
Create the simulation configuration dataclass following the pattern from research:

1. Create `src/asset_optimization/simulation/` directory
2. Create `config.py` with `SimulationConfig`:

```python
@dataclass(frozen=True)
class SimulationConfig:
    """Immutable simulation configuration.

    Parameters
    ----------
    n_years : int
        Number of years to simulate (e.g., 10, 20, 30)
    start_year : int
        Calendar year to start simulation (default: 2026)
    random_seed : int, optional
        Seed for reproducible results (None = non-deterministic)
    track_asset_history : bool
        Whether to save full asset-level traces (memory-intensive)
    failure_response : str
        How to handle failures: 'replace', 'repair', 'record_only'
    """
    n_years: int
    start_year: int = 2026
    random_seed: Optional[int] = None
    track_asset_history: bool = False
    failure_response: str = 'replace'
```

3. Implement `__post_init__` validation:
   - n_years must be > 0
   - failure_response must be in ['replace', 'repair', 'record_only']
   - Raise ValueError with descriptive messages on invalid input

4. Create `__init__.py` exporting SimulationConfig

Follow the frozen=True pattern for immutability (research recommendation).
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "
from asset_optimization.simulation import SimulationConfig

# Valid config
config = SimulationConfig(n_years=10, random_seed=42)
print(f'Valid config: n_years={config.n_years}, seed={config.random_seed}')

# Test immutability (should fail)
try:
    config.n_years = 20
    print('ERROR: Should have raised FrozenInstanceError')
except Exception as e:
    print(f'Immutability works: {type(e).__name__}')

# Test validation
try:
    SimulationConfig(n_years=0)
    print('ERROR: Should have raised ValueError')
except ValueError as e:
    print(f'Validation works: {e}')
"
```
  </verify>
  <done>SimulationConfig is immutable, validates inputs, and exports from simulation package</done>
</task>

<task type="auto">
  <name>Task 2: Create SimulationResult dataclass</name>
  <files>
    src/asset_optimization/simulation/result.py
    src/asset_optimization/simulation/__init__.py
    src/asset_optimization/exceptions.py
  </files>
  <action>
Create the simulation result dataclass:

1. Create `result.py` with `SimulationResult`:

```python
@dataclass
class SimulationResult:
    """Results from simulation run.

    Attributes
    ----------
    summary : pd.DataFrame
        Summary statistics per year with columns:
        - year, total_cost, failure_count, intervention_count, avg_age
    cost_breakdown : pd.DataFrame
        Cost breakdown by intervention type and asset type
    failure_log : pd.DataFrame
        Event log of all failures with columns:
        - year, asset_id, age_at_failure, material, direct_cost, consequence_cost
    config : SimulationConfig
        Configuration used for this run (for reproducibility)
    asset_history : pd.DataFrame, optional
        Full asset-level traces (only if config.track_asset_history=True)
    """
    summary: pd.DataFrame
    cost_breakdown: pd.DataFrame
    failure_log: pd.DataFrame
    config: 'SimulationConfig'
    asset_history: Optional[pd.DataFrame] = None
```

2. Add convenience methods:
   - `total_cost() -> float` - sum of summary['total_cost']
   - `total_failures() -> int` - sum of summary['failure_count']
   - `__repr__()` - rich representation showing years, total cost, failures

3. Update `__init__.py` to export SimulationResult

4. Add SimulationError to exceptions.py for simulation-specific errors (inherit from base ValidationError pattern)
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "
import pandas as pd
from asset_optimization.simulation import SimulationConfig, SimulationResult

# Create mock result
config = SimulationConfig(n_years=10)
summary = pd.DataFrame({
    'year': [2026, 2027, 2028],
    'total_cost': [100000.0, 120000.0, 90000.0],
    'failure_count': [5, 7, 3],
})
result = SimulationResult(
    summary=summary,
    cost_breakdown=pd.DataFrame(),
    failure_log=pd.DataFrame(),
    config=config,
)

print(f'Total cost: \${result.total_cost():,.0f}')
print(f'Total failures: {result.total_failures()}')
print(repr(result))
"
```
  </verify>
  <done>SimulationResult has summary, cost_breakdown, failure_log DataFrames and convenience methods</done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
cd /Users/henkgriffioen/code/asset-optimization

# Verify imports from package root
python -c "
from asset_optimization.simulation import SimulationConfig, SimulationResult
print('Imports work')
"

# Run any existing tests
pytest tests/ -v --tb=short 2>/dev/null || echo "No test failures expected yet"
```
</verification>

<success_criteria>
- SimulationConfig is frozen dataclass with validation in __post_init__
- SimulationResult has summary, cost_breakdown, failure_log, config, optional asset_history
- Both classes export from asset_optimization.simulation package
- Convenience methods total_cost() and total_failures() work correctly
- SimulationError added to exceptions module
</success_criteria>

<output>
After completion, create `.planning/phases/03-simulation-core/03-01-SUMMARY.md`
</output>
