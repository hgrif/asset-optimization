---
phase: 06-asset-traceability
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/asset_optimization/portfolio.py
  - src/asset_optimization/schema.py
  - src/asset_optimization/__init__.py
  - src/asset_optimization/simulation/simulator.py
  - src/asset_optimization/optimization/optimizer.py
  - tests/conftest.py
  - tests/test_portfolio.py
  - tests/test_validation.py
  - tests/test_simulation.py
  - tests/test_optimization.py
  - tests/test_end_to_end.py
autonomous: true

must_haves:
  truths:
    - "Simulator and Optimizer accept pandas DataFrame inputs and validate them internally"
    - "Portfolio class is removed from the public API (no __init__ export)"
    - "Validation errors still surface as ValidationError with field/message/details"
  artifacts:
    - path: "src/asset_optimization/portfolio.py"
      provides: "Internal DataFrame alias and validation helpers"
    - path: "src/asset_optimization/simulation/simulator.py"
      provides: "DataFrame-first simulator entrypoint"
    - path: "src/asset_optimization/optimization/optimizer.py"
      provides: "DataFrame-first optimizer entrypoint"
    - path: "tests/test_validation.py"
      provides: "Validation errors asserted without Portfolio class"
  key_links:
    - from: "src/asset_optimization/simulation/simulator.py"
      to: "src/asset_optimization/schema.py"
      via: "validate_portfolio() helper"
      pattern: "validate_portfolio"
    - from: "src/asset_optimization/optimization/optimizer.py"
      to: "src/asset_optimization/schema.py"
      via: "validate_portfolio() helper"
      pattern: "validate_portfolio"
---

<objective>
Simplify portfolio handling by treating it as a DataFrame, removing the Portfolio class from the public API, and moving validation into the simulation/optimization entrypoints.

Purpose: reduce redundant abstraction, make DataFrame the primary interface, and keep validation centralized where data is consumed.
Output: internal validation helper, DataFrame-first simulator/optimizer, updated tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-asset-traceability/06-CONTEXT.md

# Current implementation
@src/asset_optimization/portfolio.py
@src/asset_optimization/schema.py
@src/asset_optimization/simulation/simulator.py
@src/asset_optimization/optimization/optimizer.py
@tests/test_portfolio.py
@tests/test_validation.py
@tests/test_end_to_end.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Portfolio class with internal helpers</name>
  <files>
    src/asset_optimization/portfolio.py
    src/asset_optimization/schema.py
  </files>
  <action>
1. Remove the public Portfolio class. Replace with:
   - `PortfolioFrame = pd.DataFrame` type alias for internal typing
   - `validate_portfolio(df: pd.DataFrame) -> pd.DataFrame` that applies the pandera schema and raises ValidationError
   - Optional `load_portfolio_csv/load_portfolio_excel` helpers that return validated DataFrames (internal only)

2. Keep QualityMetrics computation available via a helper (return separately if needed), but avoid bundling into a wrapper class.

3. Ensure validation errors preserve `field`, `message`, and `details` attributes (use existing ValidationError in exceptions.py).
  </action>
  <verify>
    python -c "import asset_optimization as ao; assert 'Portfolio' not in ao.__all__"
  </verify>
  <done>
    - Portfolio class removed or clearly marked internal
    - validate_portfolio helper exists and raises ValidationError on bad input
  </done>
</task>

<task type="auto">
  <name>Task 2: Update simulator and optimizer to accept DataFrames</name>
  <files>
    src/asset_optimization/simulation/simulator.py
    src/asset_optimization/optimization/optimizer.py
    src/asset_optimization/__init__.py
  </files>
  <action>
1. Update type hints and docstrings to accept pandas DataFrame (PortfolioFrame).
2. Call validate_portfolio() at the start of Simulator.run() and Optimizer.fit() to ensure schemas are enforced.
3. Replace `portfolio.data` and `len(portfolio)` usage with direct DataFrame operations.
4. Remove Portfolio from top-level exports in __init__.py.
  </action>
  <verify>
    python -c "import asset_optimization as ao; assert 'Portfolio' not in ao.__all__"
  </verify>
  <done>
    - Simulator.run and Optimizer.fit accept DataFrame input
    - Validation happens inside consumer classes
    - Portfolio not exported publicly
  </done>
</task>

<task type="auto">
  <name>Task 3: Update tests and fixtures for DataFrame-only portfolio</name>
  <files>
    tests/conftest.py
    tests/test_portfolio.py
    tests/test_validation.py
    tests/test_simulation.py
    tests/test_optimization.py
    tests/test_end_to_end.py
  </files>
  <action>
1. Replace Portfolio fixtures with DataFrame fixtures.
2. Convert test_portfolio.py to validate helper behavior or remove/recreate as test_portfolio_validation.py.
3. Update validation tests to call validate_portfolio() (or simulation/optimizer entrypoints) instead of Portfolio.from_*.
4. Update the end-to-end test to use DataFrame inputs directly.
5. Ensure optimization/simulation tests still cover validation failures for bad inputs.
  </action>
  <verify>
    uv run pytest tests/ -q
  </verify>
  <done>
    - Test suite no longer imports Portfolio
    - Validation tests remain intact using DataFrame inputs
    - End-to-end test passes with DataFrame inputs
  </done>
</task>

</tasks>
