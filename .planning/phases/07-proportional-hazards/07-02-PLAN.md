---
phase: 07-proportional-hazards
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/asset_optimization/models/base.py
  - src/asset_optimization/models/weibull.py
  - src/asset_optimization/models/proportional_hazards.py
  - src/asset_optimization/simulation/simulator.py
  - tests/test_proportional_hazards.py
  - tests/test_deterioration.py
autonomous: true

must_haves:
  truths:
    - "DeteriorationModel exposes calculate_conditional_probability interface"
    - "WeibullModel implements calculate_conditional_probability"
    - "ProportionalHazardsModel implements calculate_conditional_probability"
    - "Simulator uses model.calculate_conditional_probability for all models"
    - "Existing WeibullModel simulations continue to work unchanged"
  artifacts:
    - path: "src/asset_optimization/models/base.py"
      provides: "calculate_conditional_probability abstract method"
      contains: "def calculate_conditional_probability"
    - path: "src/asset_optimization/models/weibull.py"
      provides: "calculate_conditional_probability method"
      contains: "def calculate_conditional_probability"
    - path: "src/asset_optimization/models/proportional_hazards.py"
      provides: "calculate_conditional_probability method"
      contains: "def calculate_conditional_probability"
    - path: "src/asset_optimization/simulation/simulator.py"
      provides: "Model-level conditional probability call"
      contains: "model.calculate_conditional_probability"
  key_links:
    - from: "src/asset_optimization/simulation/simulator.py"
      to: "src/asset_optimization/models/base.py"
      via: "calculate_conditional_probability interface"
      pattern: "calculate_conditional_probability"
---

<objective>
Implement a cleaner, model-driven interface for conditional failure probabilities:
- Add calculate_conditional_probability to the DeteriorationModel interface.
- Implement it in WeibullModel and ProportionalHazardsModel.
- Update Simulator to always call the model method (no Weibull-specific logic).

Purpose: Reduce Simulator coupling to Weibull internals and provide a uniform
integration point for future models.

Output: Simulator uses a consistent model interface, and existing WeibullModel
behavior remains unchanged.

**Scope note:** Optimizer integration (covariate-aware risk_after) remains
deferred to a future phase. Optimizer.fit() will still use baseline-only
risk_after via Weibull CDF, but will not break because the wrapper delegates
params and type_column.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md

Note: This plan modifies files created by 07-01. Preserve all existing content
from 07-01 when adding new methods/tests.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-proportional-hazards/07-RESEARCH.md
@.planning/phases/07-proportional-hazards/07-01-SUMMARY.md

# Key source files
@src/asset_optimization/models/base.py
@src/asset_optimization/models/weibull.py
@src/asset_optimization/models/proportional_hazards.py
@src/asset_optimization/simulation/simulator.py
@tests/test_deterioration.py
@tests/test_proportional_hazards.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add calculate_conditional_probability to DeteriorationModel</name>
  <files>src/asset_optimization/models/base.py</files>
  <action>
Add an abstract method to DeteriorationModel:

```python
@abstractmethod
def calculate_conditional_probability(self, state: pd.DataFrame) -> np.ndarray:
    """Calculate P(fail in [t, t+1) | survived to t).

    Parameters
    ----------
    state : pd.DataFrame
        Current asset state with at least age and type columns.

    Returns
    -------
    np.ndarray
        Conditional failure probabilities for each asset.
    """
```

Notes:
- Keep the method abstract (no implementation).
- Align wording with existing docstring style in base.py.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "from asset_optimization.models import DeteriorationModel; print('Base interface OK')"
```
  </verify>
  <done>
DeteriorationModel declares calculate_conditional_probability().
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement calculate_conditional_probability in WeibullModel</name>
  <files>src/asset_optimization/models/weibull.py</files>
  <action>
Add a method using the existing Simulator math, but owned by the model:

```python
def calculate_conditional_probability(self, state: pd.DataFrame) -> np.ndarray:
    """Calculate P(fail in [t, t+1) | survived to t)."""
```

Implementation steps:
1. Validate input using existing _validate_dataframe (same requirements as transform()).
2. Initialize probs array of length len(state).
3. Group by self.type_column and for each asset_type:
   - shape, scale = self.params[asset_type]
   - ages = group[self.age_column].values
   - S(t) = weibull_min.sf(ages, c=shape, scale=scale)
   - S(t+1) = weibull_min.sf(ages + 1, c=shape, scale=scale)
   - cond_prob = (S(t) - S(t+1)) / S(t)
   - If S(t) == 0, set cond_prob = 1.0
   - Clip to [0, 1]
4. Return probs

Notes:
- Preserve the existing numerical behavior from Simulator.
- Do not modify the input DataFrame.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "from asset_optimization.models import WeibullModel; import pandas as pd; m=WeibullModel({'PVC': (2.5, 50)}); s=pd.DataFrame({'material':['PVC'], 'age':[20]}); print(m.calculate_conditional_probability(s))"
```
  </verify>
  <done>
WeibullModel.calculate_conditional_probability() returns valid probabilities.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement calculate_conditional_probability in ProportionalHazardsModel</name>
  <files>src/asset_optimization/models/proportional_hazards.py</files>
  <action>
Add `calculate_conditional_probability(state: pd.DataFrame) -> np.ndarray` using the
Weibull-PH formula:

```
S(t|x) = S0(t)^r, r = exp(beta'x)
P(fail in [t,t+1) | survived to t, x) = 1 - (S0(t+1)/S0(t))^r
```

Implementation steps:
1. Compute risk_score per row via _risk_score(state).
2. For each asset type group:
   - Get Weibull params via self.params
   - Compute S0(t) and S0(t+1) using weibull_min.sf
   - Compute survival_ratio = S0(t+1) / S0(t) (handle S0(t)=0)
   - Apply r = risk_score to get cond_prob = 1 - survival_ratio ** r
   - Clip to [0, 1]
3. Return array of probabilities aligned to state index

Note: This method should assume a Weibull baseline for exact math; for other
baselines, apply the same survival_ratio^r pattern as an approximation and
clip to [0, 1]. Document this in the method docstring.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
python -c "from asset_optimization.models import ProportionalHazardsModel, WeibullModel; import pandas as pd; b=WeibullModel({'PVC': (2.5, 50)}); ph=ProportionalHazardsModel(b, covariates=['x'], coefficients={'x': 0.1}); s=pd.DataFrame({'material':['PVC'], 'age':[20], 'x':[1.0]}); print(ph.calculate_conditional_probability(s))"
```
  </verify>
  <done>
ProportionalHazardsModel.calculate_conditional_probability() returns valid probabilities.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Simulator to use model interface</name>
  <files>src/asset_optimization/simulation/simulator.py</files>
  <action>
Simplify `_calculate_conditional_probability()` to delegate directly to the model:

```python
return self.model.calculate_conditional_probability(state)
```

Update the docstring to remove Weibull-specific language and describe the model
interface instead.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
pytest tests/test_simulation.py -v -k "test_" --tb=short
```
  </verify>
  <done>
Simulator uses the model interface for conditional probabilities.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add tests for conditional probability interface</name>
  <files>
    tests/test_deterioration.py
    tests/test_proportional_hazards.py
  </files>
  <action>
Add tests to cover the new interface:

In tests/test_deterioration.py:
- Add a test class for WeibullModel.calculate_conditional_probability with:
  - returns array of correct length
  - values are within [0, 1]
  - higher age yields higher conditional probability for typical params

In tests/test_proportional_hazards.py:
- Keep or add tests for ProportionalHazardsModel.calculate_conditional_probability
  - validates range and covariate monotonicity

Ensure tests are deterministic and do not rely on stochastic simulation.
  </action>
  <verify>
```bash
cd /Users/henkgriffioen/code/asset-optimization
pytest tests/test_deterioration.py -v -k "conditional_probability"
pytest tests/test_proportional_hazards.py -v -k "ConditionalProbability"
```
  </verify>
  <done>
Interface tests pass for both WeibullModel and ProportionalHazardsModel.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/henkgriffioen/code/asset-optimization

# PH tests pass
pytest tests/test_proportional_hazards.py -v

# Existing simulation tests still pass (no regression)
pytest tests/test_simulation.py -v

# Deterioration tests for Weibull interface
pytest tests/test_deterioration.py -v
```
</verification>

<success_criteria>
- DeteriorationModel declares calculate_conditional_probability()
- WeibullModel implements calculate_conditional_probability() with correct bounds
- ProportionalHazardsModel implements calculate_conditional_probability()
- Simulator delegates conditional probability to the model interface
- Existing WeibullModel simulation behavior is unchanged
- All tests pass for deterioration, proportional hazards, and simulation suites
</success_criteria>

<output>
After completion, create `.planning/phases/07-proportional-hazards/07-02-SUMMARY.md`
</output>
