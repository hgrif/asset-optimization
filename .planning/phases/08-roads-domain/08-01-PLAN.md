---
phase: 08-roads-domain
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/asset_optimization/domains/__init__.py
  - src/asset_optimization/domains/base.py
  - src/asset_optimization/domains/pipes.py
  - src/asset_optimization/__init__.py
  - tests/test_domains.py
autonomous: true

must_haves:
  truths:
    - "PipeDomain.validate(df) accepts valid pipe DataFrames and rejects invalid ones"
    - "PipeDomain.default_interventions() returns the existing pipe interventions dict"
    - "PipeDomain.default_model() returns a WeibullModel with pipe-specific parameters"
    - "Domain protocol defines validate, default_interventions, default_model methods"
    - "Existing tests still pass (no regressions from refactor)"
  artifacts:
    - path: "src/asset_optimization/domains/__init__.py"
      provides: "Public exports for domains package"
      exports: ["Domain", "PipeDomain"]
    - path: "src/asset_optimization/domains/base.py"
      provides: "Domain protocol definition"
      contains: "class Domain"
    - path: "src/asset_optimization/domains/pipes.py"
      provides: "PipeDomain class wrapping existing pipe schema and interventions"
      contains: "class PipeDomain"
    - path: "tests/test_domains.py"
      provides: "Tests for Domain interface and PipeDomain"
  key_links:
    - from: "src/asset_optimization/domains/pipes.py"
      to: "src/asset_optimization/schema.py"
      via: "PipeDomain.validate delegates to portfolio_schema"
      pattern: "portfolio_schema"
    - from: "src/asset_optimization/domains/pipes.py"
      to: "src/asset_optimization/simulation/interventions.py"
      via: "PipeDomain.default_interventions returns existing constants"
      pattern: "DO_NOTHING|INSPECT|REPAIR|REPLACE"
---

<objective>
Create the `domains/` package with a Domain protocol and refactor existing pipe functionality into PipeDomain.

Purpose: Establishes the domain pattern that both PipeDomain and RoadDomain will follow. Proves the abstraction works by wrapping existing pipe code first.
Output: `domains/` package with Domain protocol and PipeDomain, with full test coverage.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-roads-domain/08-CONTEXT.md
@src/asset_optimization/schema.py
@src/asset_optimization/simulation/interventions.py
@src/asset_optimization/models/weibull.py
@src/asset_optimization/portfolio.py
@src/asset_optimization/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain protocol and PipeDomain with tests (TDD)</name>
  <files>
    src/asset_optimization/domains/__init__.py
    src/asset_optimization/domains/base.py
    src/asset_optimization/domains/pipes.py
    tests/test_domains.py
  </files>
  <action>
**RED phase — write failing tests first in `tests/test_domains.py`:**

Create test classes:

1. `TestDomainProtocol`:
   - Test that PipeDomain satisfies the Domain protocol (isinstance or structural check)

2. `TestPipeDomainValidate`:
   - Test `PipeDomain().validate(df)` with valid pipe DataFrame (has asset_id, install_date, asset_type, material) returns validated DataFrame
   - Test `PipeDomain().validate(df)` raises ValidationError when required columns missing (e.g., no asset_id)
   - Test `PipeDomain().validate(df)` with extra columns works (strict=False)

3. `TestPipeDomainDefaultInterventions`:
   - Test returns dict with keys: "do_nothing", "inspect", "repair", "replace"
   - Test each value is an InterventionType instance
   - Test costs match existing constants (0, 500, 5000, 50000)

4. `TestPipeDomainDefaultModel`:
   - Test returns a WeibullModel instance
   - Test model has parameters for "PVC" and "Cast Iron" (the standard pipe materials)
   - Test model type_column is "material"

Run tests — they must FAIL.

**GREEN phase — implement to make tests pass:**

Create `src/asset_optimization/domains/base.py`:
- Define `Domain` as a `typing.Protocol` (runtime_checkable) with three methods:
  - `validate(self, df: pd.DataFrame) -> pd.DataFrame`
  - `default_interventions(self) -> dict[str, InterventionType]`
  - `default_model(self) -> DeteriorationModel`

Create `src/asset_optimization/domains/pipes.py`:
- `PipeDomain` class implementing the Domain protocol
- `validate(df)`: delegates to `portfolio_schema.validate(df.copy(), lazy=False)` wrapped in try/except converting SchemaError to ValidationError (reuse pattern from portfolio.py)
- `default_interventions()`: returns dict mapping "do_nothing" -> DO_NOTHING, "inspect" -> INSPECT, "repair" -> REPAIR, "replace" -> REPLACE (the existing constants)
- `default_model()`: returns `WeibullModel({"PVC": (2.5, 50.0), "Cast Iron": (3.0, 40.0)})` — these are the standard pipe parameters used throughout the codebase

Create `src/asset_optimization/domains/__init__.py`:
- Export Domain and PipeDomain

Run tests — they must PASS.

Use NumPy-style docstrings. Use type hints for all public methods.
  </action>
  <verify>
    `uv run pytest tests/test_domains.py -v` — all tests pass
    `uv run pytest` — all existing tests still pass (no regressions)
  </verify>
  <done>
    Domain protocol defined with validate/default_interventions/default_model.
    PipeDomain wraps existing pipe schema, interventions, and model parameters.
    All tests pass including existing test suite.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register domains in package __init__ and verify exports</name>
  <files>
    src/asset_optimization/__init__.py
  </files>
  <action>
Add Domain and PipeDomain to the top-level package exports:

1. Add import: `from .domains import Domain, PipeDomain`
2. Add to `__all__` list: `"Domain"`, `"PipeDomain"`

This allows users to do `from asset_optimization import PipeDomain`.

Do NOT modify any existing exports or remove any existing imports.
  </action>
  <verify>
    `uv run python -c "from asset_optimization import Domain, PipeDomain; print(PipeDomain()); print('OK')"`
    `uv run pytest` — all tests pass
    `make lint` — no lint errors
  </verify>
  <done>
    Domain and PipeDomain are importable from the top-level package.
    All existing exports unchanged. All tests pass. Lint clean.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_domains.py -v` — domain tests pass
2. `uv run pytest` — full suite passes (no regressions)
3. `make lint` — clean
4. `uv run python -c "from asset_optimization import Domain, PipeDomain; d = PipeDomain(); print(d.default_interventions()); print(d.default_model())"` — works
</verification>

<success_criteria>
- Domain protocol exists with validate/default_interventions/default_model
- PipeDomain implements Domain protocol using existing pipe schema and interventions
- PipeDomain is importable from top-level package
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/08-roads-domain/08-01-SUMMARY.md`
</output>
