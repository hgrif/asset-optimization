---
phase: 08-roads-domain
plan: 02
type: tdd
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/asset_optimization/domains/roads.py
  - src/asset_optimization/domains/__init__.py
  - src/asset_optimization/__init__.py
  - tests/test_roads_domain.py
autonomous: true

must_haves:
  truths:
    - "RoadDomain.validate(df) accepts DataFrames with asset_id, install_date, surface_type, traffic_load, climate_zone"
    - "RoadDomain.validate(df) rejects DataFrames missing required road columns"
    - "RoadDomain.validate(df) rejects invalid categorical values (e.g., surface_type='rubber')"
    - "RoadDomain.default_interventions() returns 5 intervention types: do_nothing, inspect, patch, resurface, reconstruct"
    - "Intervention costs vary by surface_type (e.g., resurfacing concrete > resurfacing asphalt)"
    - "Reconstruct intervention has upgrade_type set (changes surface type)"
    - "RoadDomain.default_model() returns ProportionalHazardsModel with Weibull baseline"
    - "Default model uses traffic_load and climate_zone as covariates with research-backed coefficients"
  artifacts:
    - path: "src/asset_optimization/domains/roads.py"
      provides: "RoadDomain class with road-specific schema, interventions, and model"
      contains: "class RoadDomain"
    - path: "tests/test_roads_domain.py"
      provides: "Comprehensive tests for RoadDomain"
  key_links:
    - from: "src/asset_optimization/domains/roads.py"
      to: "src/asset_optimization/models/proportional_hazards.py"
      via: "RoadDomain.default_model returns ProportionalHazardsModel"
      pattern: "ProportionalHazardsModel"
    - from: "src/asset_optimization/domains/roads.py"
      to: "src/asset_optimization/simulation/interventions.py"
      via: "Road interventions use InterventionType dataclass"
      pattern: "InterventionType"
---

<objective>
Implement RoadDomain with road-specific schema validation, intervention types, and deterioration model defaults.

Purpose: Enables users to configure and simulate road asset portfolios using the domain pattern established in Plan 01. This is the core deliverable of Phase 8.
Output: Working RoadDomain class with research-backed defaults, full test coverage.
</objective>

<execution_context>
@/Users/henkgriffioen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/henkgriffioen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-roads-domain/08-CONTEXT.md
@.planning/phases/08-roads-domain/08-01-SUMMARY.md
@src/asset_optimization/domains/base.py
@src/asset_optimization/domains/pipes.py
@src/asset_optimization/simulation/interventions.py
@src/asset_optimization/models/proportional_hazards.py
@src/asset_optimization/models/weibull.py
@src/asset_optimization/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RoadDomain implementation with tests (TDD)</name>
  <files>
    src/asset_optimization/domains/roads.py
    tests/test_roads_domain.py
  </files>
  <action>
**RED phase — write failing tests first in `tests/test_roads_domain.py`:**

Create test classes:

1. `TestRoadDomainValidate`:
   - Test valid road DataFrame (has asset_id, install_date, surface_type, traffic_load, climate_zone) passes validation
   - Test missing required column (e.g., no surface_type) raises ValidationError
   - Test invalid surface_type value (e.g., "rubber") raises ValidationError
   - Test invalid traffic_load value (e.g., "extreme") raises ValidationError
   - Test invalid climate_zone value (e.g., "tropical") raises ValidationError
   - Test extra columns allowed (strict=False)
   - Test coercion works (e.g., string dates -> Timestamp)
   - Test validate returns a copy, does not mutate input

2. `TestRoadDomainDefaultInterventions`:
   - Test returns dict with 5 keys: "do_nothing", "inspect", "patch", "resurface", "reconstruct"
   - Test each value is InterventionType instance
   - Test do_nothing cost is 0
   - Test reconstruct has upgrade_type set (not None)
   - Test calling with surface_type="asphalt" vs "concrete" returns different costs for resurface and reconstruct
   - Test patch age_effect reduces age (but not to zero)
   - Test resurface age_effect reduces age significantly (but not to zero)
   - Test reconstruct age_effect resets age to 0

3. `TestRoadDomainDefaultModel`:
   - Test returns ProportionalHazardsModel instance
   - Test baseline is WeibullModel
   - Test covariates include traffic_load and climate_zone (as numeric encodings)
   - Test model has parameters for each surface type (asphalt, concrete, gravel)
   - Test model type_column matches the road surface type column name

4. `TestRoadDomainProtocol`:
   - Test RoadDomain satisfies the Domain protocol

Run tests — they must FAIL.

**GREEN phase — implement `src/asset_optimization/domains/roads.py`:**

**Research-backed road parameters** (use these defaults):

Surface types: `asphalt`, `concrete`, `gravel`

Traffic load levels: `low`, `medium`, `high` (encode as 1, 2, 3 for covariate use)

Climate zones: `temperate`, `cold`, `hot_dry`, `hot_humid` (encode as 1, 2, 3, 4)

**Weibull baseline parameters per surface type** (shape, scale in years):
- asphalt: (3.5, 20) — typical asphalt pavement life ~15-25 years, shape ~3-4 (wear-out)
- concrete: (2.8, 35) — concrete lasts longer ~25-40 years, lower shape (slower wear-out)
- gravel: (4.0, 12) — gravel deteriorates faster ~8-15 years, high shape (rapid wear-out)

**Proportional hazards coefficients:**
- traffic_load: 0.35 (higher traffic -> higher failure rate; doubling traffic level ~1.4x hazard)
- climate_zone: 0.15 (harsher climate -> higher failure rate; moderate effect)

These are realistic starting points based on pavement engineering literature.

**Road interventions (costs in $/km):**

For asphalt:
- do_nothing: cost=0, age_effect=identity
- inspect: cost=500, age_effect=identity
- patch: cost=15_000, age_effect=lambda age: max(0, age - 3)
- resurface: cost=80_000, age_effect=lambda age: max(0, age - 12)
- reconstruct: cost=250_000, age_effect=lambda age: 0, upgrade_type="asphalt"

For concrete:
- do_nothing: cost=0, age_effect=identity
- inspect: cost=500, age_effect=identity
- patch: cost=20_000, age_effect=lambda age: max(0, age - 3)
- resurface: cost=120_000, age_effect=lambda age: max(0, age - 15)
- reconstruct: cost=400_000, age_effect=lambda age: 0, upgrade_type="concrete"

For gravel:
- do_nothing: cost=0, age_effect=identity
- inspect: cost=300, age_effect=identity
- patch: cost=8_000, age_effect=lambda age: max(0, age - 2)
- resurface: cost=40_000, age_effect=lambda age: max(0, age - 8)
- reconstruct: cost=200_000, age_effect=lambda age: 0, upgrade_type="asphalt" (gravel->asphalt upgrade)

**Implementation details:**

`RoadDomain` class:

- Constructor takes no arguments (defaults are built-in)
- Define road-specific Pandera schema internally (not extending pipe schema):
  - Required: asset_id (str, unique), install_date (Timestamp), surface_type (str, isin values), traffic_load (str, isin values), climate_zone (str, isin values)
  - Optional: length_km (float, >0), condition_score (float, 0-100)
  - strict=False, coerce=True
- `validate(df)`: use the road Pandera schema, catch SchemaError -> ValidationError (same pattern as PipeDomain)
- `default_interventions(surface_type="asphalt")`: return dict of 5 InterventionType instances with costs for the given surface type. The surface_type parameter controls cost lookup. Default to asphalt.
- `default_model()`: return ProportionalHazardsModel(baseline=WeibullModel(road_params, type_column="surface_type"), covariates=["traffic_load_encoded", "climate_zone_encoded"], coefficients={"traffic_load_encoded": 0.35, "climate_zone_encoded": 0.15})
- Add a static method `encode_covariates(df)` that takes a road DataFrame and adds numeric columns `traffic_load_encoded` (low=1, medium=2, high=3) and `climate_zone_encoded` (temperate=1, cold=2, hot_dry=3, hot_humid=4) for use with ProportionalHazardsModel

Use NumPy-style docstrings. Use type hints for all public methods.
Validate surface_type in default_interventions — raise ValueError for unknown types.

Run tests — they must PASS.
  </action>
  <verify>
    `uv run pytest tests/test_roads_domain.py -v` — all tests pass
    `uv run pytest` — full suite passes
  </verify>
  <done>
    RoadDomain validates road-specific schema (surface_type, traffic_load, climate_zone).
    RoadDomain returns surface-type-specific interventions with research-backed costs.
    RoadDomain returns ProportionalHazardsModel with Weibull baseline per surface type.
    Covariate encoding helper converts categorical road properties to numeric.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register RoadDomain in package exports</name>
  <files>
    src/asset_optimization/domains/__init__.py
    src/asset_optimization/__init__.py
  </files>
  <action>
1. In `src/asset_optimization/domains/__init__.py`: add import and export of `RoadDomain`
2. In `src/asset_optimization/__init__.py`: add `RoadDomain` to imports from `.domains` and add to `__all__`

This enables `from asset_optimization import RoadDomain`.
  </action>
  <verify>
    `uv run python -c "from asset_optimization import RoadDomain; d = RoadDomain(); print(d.default_interventions()); print(d.default_model()); print('OK')"`
    `uv run pytest` — all tests pass
    `make lint` — clean
  </verify>
  <done>
    RoadDomain importable from top-level package. All tests pass. Lint clean.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_roads_domain.py -v` — road domain tests pass
2. `uv run pytest` — full suite passes
3. `make lint` — clean
4. `uv run python -c "from asset_optimization import RoadDomain; d = RoadDomain(); print(d.validate.__doc__[:50]); print(len(d.default_interventions())); print(type(d.default_model()).__name__)"` — prints method doc, 5, ProportionalHazardsModel
</verification>

<success_criteria>
- RoadDomain validates road DataFrames with surface_type, traffic_load, climate_zone
- RoadDomain returns 5 interventions with surface-type-specific costs
- RoadDomain returns ProportionalHazardsModel with realistic road parameters
- Covariate encoding converts categorical columns to numeric
- All tests pass, lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/08-roads-domain/08-02-SUMMARY.md`
</output>
